Only in /home/robert/Development/tork/src/tsocks/: .#Makefile.in.1.12
Only in /home/robert/Development/tork/src/tsocks/: .deps
Only in /home/robert/Development/tork/src/tsocks/: .libs
Only in /home/robert/Development/tork/src/tsocks/: CVS
diff -y -x Makefile.am -x Makefile.in -x configure -x INSTALL -x README.TORDNS -x COPYING -x Changelog -x Doxyfile -x FAQ -x TODO ./ChangeLog /home/robert/Development/tork/src/tsocks/ChangeLog
version 1.81 - 2006.11.17 ruben@ugr.es			      |	Renamed for TorK to avoid conflicts with existing tsocks inst
  Integrated and resolved the conflicts for the following     |	Robert Hogan
  patches:						      <
    -DNS from totalinfosecurity mentioned below		      <
    -Infinite Loop from weasel				      <
    -Getpeername from weasel				      <
    -Documentation patch from Roderick Schertler	      <
    -Localhost patch from Roger Dingledine		      <
  (patches 1, 3, 4, 5 and 7 from 			      <
  http://wiki.noreply.org/noreply/TheOnionRouter/TSocksPatche <
  Patches 2 and 6 were not applied because I don't have acces <
  osx or bsd and can't test them. (And the bsd patch breaks l <

version 1.80tordns - 2005.10.4 bls@totalinfosecurity.com	version 1.80tordns - 2005.10.4 bls@totalinfosecurity.com
   Intercept gethostbyname() and friends, added --tordns	   Intercept gethostbyname() and friends, added --tordns
   option for better name resolution with Tor.			   option for better name resolution with Tor.

version 1.80Beta5 - 2002.?.?? delius@progsoc.uts.edu.au		version 1.80Beta5 - 2002.?.?? delius@progsoc.uts.edu.au
   Intercept close() to fix problems with tsocks and 		   Intercept close() to fix problems with tsocks and 
      kmail 							      kmail 
   Add FAQ to distribution					   Add FAQ to distribution

version 1.80Beta4 - 2002.3.17 delius@progsoc.uts.edu.au		version 1.80Beta4 - 2002.3.17 delius@progsoc.uts.edu.au
   Allow TSOCKS_CONF_FILE to specify location of config		   Allow TSOCKS_CONF_FILE to specify location of config
   If the config is not found, assume all local			   If the config is not found, assume all local
   Now respects the default_user and pass specified for path	   Now respects the default_user and pass specified for path
   Added the tsocks shell script and tsocks(1) from the		   Added the tsocks shell script and tsocks(1) from the
      debian package						      debian package

version 1.80Beta3 - 2002.2.20 delius@progsoc.uts.edu.au		version 1.80Beta3 - 2002.2.20 delius@progsoc.uts.edu.au
   A large portion of tsocks has been rewritten			   A large portion of tsocks has been rewritten
   Relax parser handling of whitespace, i.e it's ignored	   Relax parser handling of whitespace, i.e it's ignored
   Fix validateconf path detection to handle local paths	   Fix validateconf path detection to handle local paths
   Expand logging/debugging support, can now provide 		   Expand logging/debugging support, can now provide 
      detailed debugging info to stderr or file)		      detailed debugging info to stderr or file)
   Improve autoconf script, much more robust			   Improve autoconf script, much more robust
   Default to ECONNREFUSED when no valid server found		   Default to ECONNREFUSED when no valid server found
   Support for non-blocking sockets by intercepting 		   Support for non-blocking sockets by intercepting 
      select() and poll()					      select() and poll()
   Add support for DESTDIR during make for RPM build, 		   Add support for DESTDIR during make for RPM build, 
   Don't insist on root.root installation			   Don't insist on root.root installation
   Document the --libdir vs --prefix difference better		   Document the --libdir vs --prefix difference better
      in INSTALL and tsocks.8					      in INSTALL and tsocks.8

version 1.80Beta2 - 2002.1.19 delius@progsoc.uts.edu.au		version 1.80Beta2 - 2002.1.19 delius@progsoc.uts.edu.au
   Fix showstopper bug with SOCKS server port numbers		   Fix showstopper bug with SOCKS server port numbers

version 1.80Beta - 2002.1.12 delius@progsoc.uts.edu.au		version 1.80Beta - 2002.1.12 delius@progsoc.uts.edu.au
   Allow choice of SOCKS server by port number (based on 	   Allow choice of SOCKS server by port number (based on 
      suggestions from Joakim Recht)				      suggestions from Joakim Recht)
   Fix bugs with error logging (reported by Paul Pot)		   Fix bugs with error logging (reported by Paul Pot)

version 1.70Beta4 - 2001.7.11 delius@progsoc.uts.edu.au		version 1.70Beta4 - 2001.7.11 delius@progsoc.uts.edu.au
	References to verifyconf fixed to point to validateco		References to verifyconf fixed to point to validateco

version 1.70Beta3 - 2001.3.13 delius@progsoc.uts.edu.au		version 1.70Beta3 - 2001.3.13 delius@progsoc.uts.edu.au
	Late resolution of socks servers				Late resolution of socks servers
	Addition of validateconf to check configuration			Addition of validateconf to check configuration
	Conf file location can now be specified to configure 		Conf file location can now be specified to configure 
	Much advanced configuration syntax allowing multiple 		Much advanced configuration syntax allowing multiple 
	Default user can now be specified without password (b		Default user can now be specified without password (b
		without user)							without user)
	Much improved documentation (with new tsocks.conf(5) 		Much improved documentation (with new tsocks.conf(5) 

version 1.70Beta2 - 2001.3.3 delius@progsoc.uts.edu.au		version 1.70Beta2 - 2001.3.3 delius@progsoc.uts.edu.au
	Showstopper bug with socks server subnet verification		Showstopper bug with socks server subnet verification
	Return code and errno issues corrected				Return code and errno issues corrected
	Correct use of sockaddr union under Linux			Correct use of sockaddr union under Linux

version 1.70Beta - 2001.2.27 delius@progsoc.uts.edu.au		version 1.70Beta - 2001.2.27 delius@progsoc.uts.edu.au
	Automated configuration using the GNU autoconf suite		Automated configuration using the GNU autoconf suite
	RH7 Compilation issues resolved					RH7 Compilation issues resolved
	SOCKS servers can now be specified as hostnames			SOCKS servers can now be specified as hostnames
	Security problems with lengths of usernames and passw		Security problems with lengths of usernames and passw
	Installation process in makefile improved			Installation process in makefile improved
	Common functions cleaned up and moved to seperate mod		Common functions cleaned up and moved to seperate mod
	Configuration read delayed to reduce overhead for UDP		Configuration read delayed to reduce overhead for UDP
	Silly debug messages removed					Silly debug messages removed

version 1.60 - 2000.7.11 delius@progsoc.uts.edu.au		version 1.60 - 2000.7.11 delius@progsoc.uts.edu.au
	Fixed segmentation fault when reading configuration f		Fixed segmentation fault when reading configuration f
	Fixed Makefile.solaris issues					Fixed Makefile.solaris issues
	Corrected Solaris support, should now work I hope :)		Corrected Solaris support, should now work I hope :)
	Fixed Makefile problem						Fixed Makefile problem
	Fixed localhost issues (127.0.0.0/255.0.0.0 is now au		Fixed localhost issues (127.0.0.0/255.0.0.0 is now au
      added as a local network)					      added as a local network)
	Removed limitation to number of local nets and reduce		Removed limitation to number of local nets and reduce
      footprint							      footprint
	Added inspectsocks utility					Added inspectsocks utility
	Added initial support for SOCKS version 5			Added initial support for SOCKS version 5
	Fixed bad connect return codes					Fixed bad connect return codes
	Update man page, announce and README				Update man page, announce and README

version 1.50 - 2000.5.23 delius@progsoc.uts.edu.au		version 1.50 - 2000.5.23 delius@progsoc.uts.edu.au
	Fixed bug with setsockopt code thanks to Ronnie Misra		Fixed bug with setsockopt code thanks to Ronnie Misra
	Added support to force TCP dns lookups (i.e allow soc		Added support to force TCP dns lookups (i.e allow soc
      DNS) thanks to Joris van Rantwijk				      DNS) thanks to Joris van Rantwijk
	Properly generate errors for unresolved symbols			Properly generate errors for unresolved symbols

version 1.40 - 2000.5.12 delius@progsoc.uts.edu.au		version 1.40 - 2000.5.12 delius@progsoc.uts.edu.au
	Fix Solaris support, should now compile on 2.6, 7 and		Fix Solaris support, should now compile on 2.6, 7 and
	Fix Makefile problem						Fix Makefile problem

version 1.30 - 2000.5.10 delius@progsoc.uts.edu.au		version 1.30 - 2000.5.10 delius@progsoc.uts.edu.au
	Added server_port configuration option				Added server_port configuration option
	Experimental Solaris support					Experimental Solaris support

version 1.20 - 2000.5.5 delius@progsoc.uts.edu.au		version 1.20 - 2000.5.5 delius@progsoc.uts.edu.au
	Correctly parse configuration file (finally :))			Correctly parse configuration file (finally :))
	Configuration file renamed to tsocks.conf (conflict w		Configuration file renamed to tsocks.conf (conflict w
	Detect non local SOCKS server and show error			Detect non local SOCKS server and show error

version 1.10 - 2000.5.3 delius@progsoc.uts.edu.au		version 1.10 - 2000.5.3 delius@progsoc.uts.edu.au
	Correctly parse the SOCKS server's return code for ou		Correctly parse the SOCKS server's return code for ou
	Provide an INSTALL guide					Provide an INSTALL guide
	Improved error handling						Improved error handling
	Provide a program to try to save those people who bre		Provide a program to try to save those people who bre
      ld.so.preload file					      ld.so.preload file

version 1.00 - 2000.5.2 delius@progsoc.uts.edu.au		version 1.00 - 2000.5.2 delius@progsoc.uts.edu.au
	First Release							First Release
Only in /home/robert/Development/tork/src/tsocks/: Makefile
Only in /home/robert/Development/tork/src/tsocks/: Makefile.am~
Only in /home/robert/Development/tork/src/tsocks/: Makefile.in~
Only in /home/robert/Development/tork/src/tsocks/: README
Only in /home/robert/Development/tork/src/tsocks/: TODO~
Only in .: acconfig.h
Only in /home/robert/Development/tork/src/tsocks/: aclocal
diff -y -x Makefile.am -x Makefile.in -x configure -x INSTALL -x README.TORDNS -x COPYING -x Changelog -x Doxyfile -x FAQ -x TODO ./common.c /home/robert/Development/tork/src/tsocks/common.c
/*								/*

    commmon.c    - Common routines for the tsocks package 	    commmon.c    - Common routines for the tsocks package 

*/								*/

#include <config.h>					      |	#include "../../config.h"
#include <stdio.h>						#include <stdio.h>
#include <netdb.h>						#include <netdb.h>
#include <common.h>						#include <common.h>
#include <stdarg.h>						#include <stdarg.h>
#include <errno.h>						#include <errno.h>
#include <stdlib.h>						#include <stdlib.h>
#include <string.h>						#include <string.h>
#include <time.h>						#include <time.h>
#include <unistd.h>						#include <unistd.h>
#include <arpa/inet.h>						#include <arpa/inet.h>
							      >	#include <sys/types.h>
#include <netinet/in.h>						#include <netinet/in.h>

/* Globals */							/* Globals */
int loglevel = MSGERR;    /* The default logging level is to 	int loglevel = MSGERR;    /* The default logging level is to 
                             error messages */			                             error messages */
char logfilename[256];    /* Name of file to which log messag	char logfilename[256];    /* Name of file to which log messag
                             be redirected */			                             be redirected */
FILE *logfile = NULL;     /* File to which messages should be	FILE *logfile = NULL;     /* File to which messages should be
int logstamp = 0;         /* Timestamp (and pid stamp) messag	int logstamp = 0;         /* Timestamp (and pid stamp) messag

unsigned int resolve_ip(char *host, int showmsg, int allownam	unsigned int resolve_ip(char *host, int showmsg, int allownam
	struct hostent *new;						struct hostent *new;
	unsigned int	hostaddr;					unsigned int	hostaddr;
	struct in_addr *ip;						struct in_addr *ip;

	if ((hostaddr = inet_addr(host)) == (unsigned int) -1		if ((hostaddr = inet_addr(host)) == (unsigned int) -1
		/* We couldn't convert it as a numerical ip s			/* We couldn't convert it as a numerical ip s
		/* try it as a dns name                      			/* try it as a dns name                      
		if (allownames) {						if (allownames) {
			#ifdef HAVE_GETHOSTBYNAME					#ifdef HAVE_GETHOSTBYNAME
			if ((new = gethostbyname(host)) == (s				if ((new = gethostbyname(host)) == (s
			#endif								#endif
				return(-1);		      |					return(0);
			#ifdef HAVE_GETHOSTBYNAME					#ifdef HAVE_GETHOSTBYNAME
			} else {							} else {
				ip = ((struct in_addr *) * ne					ip = ((struct in_addr *) * ne
				hostaddr = ip -> s_addr;					hostaddr = ip -> s_addr;
				if (showmsg) 							if (showmsg) 
					printf("Connecting to						printf("Connecting to
			}								}
			#endif								#endif
		} else								} else
			return(-1);			      |				return(0);
	}								}

	return (hostaddr);						return (hostaddr);
}								}

/* Set logging options, the options are as follows:          	/* Set logging options, the options are as follows:          
/*  level - This sets the logging threshold, messages with   	/*  level - This sets the logging threshold, messages with   
/*          a higher level (i.e lower importance) will not be	/*          a higher level (i.e lower importance) will not be
/*          output. For example, if the threshold is set to  	/*          output. For example, if the threshold is set to  
/*          MSGWARN a call to log a message of level MSGDEBUG	/*          MSGWARN a call to log a message of level MSGDEBUG
/*          would be ignored. This can be set to -1 to disabl	/*          would be ignored. This can be set to -1 to disabl
/*          messages entirely                                	/*          messages entirely                                
/*  filename - This is a filename to which the messages shoul	/*  filename - This is a filename to which the messages shoul
/*             be logged instead of to standard error        	/*             be logged instead of to standard error        
/*  timestamp - This indicates that messages should be prefix	/*  timestamp - This indicates that messages should be prefix
/*              with timestamps (and the process id)         	/*              with timestamps (and the process id)         
void set_log_options(int level, char *filename, int timestamp	void set_log_options(int level, char *filename, int timestamp

   loglevel = level;						   loglevel = level;
   if (loglevel < MSGERR)					   if (loglevel < MSGERR)
      loglevel = MSGNONE;					      loglevel = MSGNONE;

   if (filename) {						   if (filename) {
      strncpy(logfilename, filename, sizeof(logfilename));	      strncpy(logfilename, filename, sizeof(logfilename));
      logfilename[sizeof(logfilename) - 1] = '\0';		      logfilename[sizeof(logfilename) - 1] = '\0';
   }								   }

   logstamp = timestamp;					   logstamp = timestamp;
}								}

/* Count the bits in a netmask.  This is a little bit buggy; 	/* Count the bits in a netmask.  This is a little bit buggy; 
   all the zeroes are on the right... */			   all the zeroes are on the right... */

int count_netmask_bits(uint32_t mask)				int count_netmask_bits(uint32_t mask)
{								{
    int i;							    int i;
    int nbits = 0;						    int nbits = 0;

    for(i=0; i<32; i++) {					    for(i=0; i<32; i++) {
        if((mask >> i) & 1) {					        if((mask >> i) & 1) {
            nbits++;						            nbits++;
        } 							        } 
    }								    }
    mask = ~mask;						    mask = ~mask;
    mask = ntohl(mask);						    mask = ntohl(mask);
    if(mask & (mask+1)) {					    if(mask & (mask+1)) {
        return -1;  /* Noncontiguous */				        return -1;  /* Noncontiguous */
    }								    }
    return nbits;						    return nbits;
}								}

void show_msg(int level, char *fmt, ...) {		      |	void show_msg(int level, const char *fmt, ...) {
	va_list ap;					      |	   va_list ap;
	int saveerr;					      |	   int saveerr;
	extern char *progname;				      |	/*   extern char *progname; */
   char timestring[20];						   char timestring[20];
   time_t timestamp;						   time_t timestamp;

   if ((loglevel == MSGNONE) || (level > loglevel))		   if ((loglevel == MSGNONE) || (level > loglevel))
      return;							      return;

   if (!logfile) {						   if (!logfile) {
      if (logfilename[0]) {					      if (logfilename[0]) {
         logfile = fopen(logfilename, "a");			         logfile = fopen(logfilename, "a");
         if (logfile == NULL) {					         if (logfile == NULL) {
            logfile = stderr;					            logfile = stderr;
            show_msg(MSGERR, "Could not open log file, %s, %s	            show_msg(MSGERR, "Could not open log file, %s, %s
                     logfilename, strerror(errno));		                     logfilename, strerror(errno));
         }							         }
      } else							      } else
         logfile = stderr;					         logfile = stderr;
   }								   }

   if (logstamp) {						   if (logstamp) {
      timestamp = time(NULL);					      timestamp = time(NULL);
      strftime(timestring, sizeof(timestring),  "%H:%M:%S", 	      strftime(timestring, sizeof(timestring),  "%H:%M:%S", 
               localtime(&timestamp));				               localtime(&timestamp));
      fprintf(logfile, "%s ", timestring);			      fprintf(logfile, "%s ", timestring);
   }								   }

   // fputs(progname, logfile);				      |	   /* fputs(progname, logfile); */

   if (logstamp) {						   if (logstamp) {
      fprintf(logfile, "(%d)", getpid());			      fprintf(logfile, "(%d)", getpid());
   }								   }
   								   
   fputs(": ", logfile);					   fputs(": ", logfile);
									
	va_start(ap, fmt);						va_start(ap, fmt);

	/* Save errno */						/* Save errno */
	saveerr = errno;						saveerr = errno;

	vfprintf(logfile, fmt, ap);					vfprintf(logfile, fmt, ap);
									
   fflush(logfile);						   fflush(logfile);

	errno = saveerr;						errno = saveerr;

	va_end(ap);							va_end(ap);
}								}

Only in /home/robert/Development/tork/src/tsocks/: common.c~
diff -y -x Makefile.am -x Makefile.in -x configure -x INSTALL -x README.TORDNS -x COPYING -x Changelog -x Doxyfile -x FAQ -x TODO ./common.h /home/robert/Development/tork/src/tsocks/common.h
/* Common functions provided in common.c */			/* Common functions provided in common.c */

void set_log_options(int, char *, int);				void set_log_options(int, char *, int);
void show_msg(int level, char *, ...);			      |	void show_msg(int level, const char *, ...);
int count_netmask_bits(uint32_t mask);				int count_netmask_bits(uint32_t mask);
unsigned int resolve_ip(char *, int, int);			unsigned int resolve_ip(char *, int, int);

#define MSGNONE   -1						#define MSGNONE   -1
#define MSGERR    0						#define MSGERR    0
#define MSGWARN   1						#define MSGWARN   1
#define MSGNOTICE 2						#define MSGNOTICE 2
#define MSGDEBUG  2						#define MSGDEBUG  2
Only in /home/robert/Development/tork/src/tsocks/: common.lo
Only in .: config.guess
Only in .: config.h.in
Only in .: config.status
Only in .: config.sub
Only in .: configure.in
diff -y -x Makefile.am -x Makefile.in -x configure -x INSTALL -x README.TORDNS -x COPYING -x Changelog -x Doxyfile -x FAQ -x TODO ./dead_pool.c /home/robert/Development/tork/src/tsocks/dead_pool.c
#include <stdio.h>						#include <stdio.h>
#include <sys/socket.h>						#include <sys/socket.h>
							      >	#include <sys/types.h>
#include <netinet/in.h>						#include <netinet/in.h>
#include <arpa/inet.h>						#include <arpa/inet.h>
#include <netdb.h>						#include <netdb.h>
#include <stdlib.h>						#include <stdlib.h>
#include <string.h>						#include <string.h>
#include <sys/mman.h>						#include <sys/mman.h>
#include "common.h"						#include "common.h"
#include "dead_pool.h"						#include "dead_pool.h"

int store_pool_entry(dead_pool *pool, char *hostname, struct 	int store_pool_entry(dead_pool *pool, char *hostname, struct 
void get_next_dead_address(dead_pool *pool, uint32_t *result)	void get_next_dead_address(dead_pool *pool, uint32_t *result)

static int							static int
do_resolve(const char *hostname, uint32_t sockshost, uint16_t	do_resolve(const char *hostname, uint32_t sockshost, uint16_t
           uint32_t *result_addr);				           uint32_t *result_addr);

/* Compares the last strlen(s2) characters of s1 with s2.  Re	/* Compares the last strlen(s2) characters of s1 with s2.  Re
   strcasecmp. */						   strcasecmp. */
static int 							static int 
strcasecmpend(const char *s1, const char *s2)			strcasecmpend(const char *s1, const char *s2)
{								{
   size_t n1 = strlen(s1), n2 = strlen(s2);			   size_t n1 = strlen(s1), n2 = strlen(s2);
   if (n2>n1) /* then they can't be the same; figure out whic	   if (n2>n1) /* then they can't be the same; figure out whic
       return strcasecmp(s1,s2);				       return strcasecmp(s1,s2);
   else								   else
       return strncasecmp(s1+(n1-n2), s2, n2);			       return strncasecmp(s1+(n1-n2), s2, n2);
}								}

dead_pool *							dead_pool *
init_pool(int pool_size, struct in_addr deadrange_base,       |	init_pool(unsigned int pool_size, struct in_addr deadrange_ba
    struct in_addr deadrange_mask, char *sockshost, uint16_t 	    struct in_addr deadrange_mask, char *sockshost, uint16_t 
{								{
    int i, deadrange_bits, deadrange_width, deadrange_size;   |	    unsigned int i, deadrange_size, deadrange_width;
							      >	    int deadrange_bits;
    struct in_addr socks_server;				    struct in_addr socks_server;
    dead_pool *newpool = NULL;					    dead_pool *newpool = NULL;

    /* Count bits in netmask and determine deadrange width. *	    /* Count bits in netmask and determine deadrange width. *
    deadrange_bits = count_netmask_bits(deadrange_mask.s_addr	    deadrange_bits = count_netmask_bits(deadrange_mask.s_addr
    if(deadrange_bits == -1) {					    if(deadrange_bits == -1) {
        show_msg(MSGERR, "init_pool: invalid netmask for dead	        show_msg(MSGERR, "init_pool: invalid netmask for dead
        return NULL;						        return NULL;
    } 								    } 
    deadrange_width = 32 - deadrange_bits;			    deadrange_width = 32 - deadrange_bits;

    show_msg(MSGDEBUG, "deadrange width is %d bits\n", deadra	    show_msg(MSGDEBUG, "deadrange width is %d bits\n", deadra

    /* Now work out how many IPs are available in the deadran	    /* Now work out how many IPs are available in the deadran
       that this number makes sense.  If the deadpool is bigg	       that this number makes sense.  If the deadpool is bigg
       deadrange we shrink the pool. */				       deadrange we shrink the pool. */

    for(i=0, deadrange_size = 1; i < deadrange_width; i++) {	    for(i=0, deadrange_size = 1; i < deadrange_width; i++) {
        deadrange_size *= 2;					        deadrange_size *= 2;
    }								    }

    if(deadrange_size < pool_size) {				    if(deadrange_size < pool_size) {
        show_msg(MSGWARN, "tordns cache size was %d, but dead	        show_msg(MSGWARN, "tordns cache size was %d, but dead
                 "shrinking pool size to %d entries\n", pool_	                 "shrinking pool size to %d entries\n", pool_
                 deadrange_size, deadrange_size);		                 deadrange_size, deadrange_size);
        pool_size = deadrange_size;				        pool_size = deadrange_size;
    }								    }
    if(pool_size < 1) {						    if(pool_size < 1) {
        show_msg(MSGERR, "tordns cache size is 0, disabling t	        show_msg(MSGERR, "tordns cache size is 0, disabling t
        return NULL;						        return NULL;
    }								    }

    /* Allocate space for the dead_pool structure */		    /* Allocate space for the dead_pool structure */
    newpool = (dead_pool *) mmap(0, sizeof(dead_pool), 		    newpool = (dead_pool *) mmap(0, sizeof(dead_pool), 
                   PROT_READ | PROT_WRITE, 			                   PROT_READ | PROT_WRITE, 
                   MAP_SHARED | MAP_ANONYMOUS, -1, 0); 		                   MAP_SHARED | MAP_ANONYMOUS, -1, 0); 
    if(!newpool) {						    if(!newpool) {
        show_msg(MSGERR, "init_pool: unable to mmap deadpool 	        show_msg(MSGERR, "init_pool: unable to mmap deadpool 
                 "(tried to map %d bytes)\n", sizeof(dead_poo	                 "(tried to map %d bytes)\n", sizeof(dead_poo
        return NULL;						        return NULL;
    }								    }

    /* Initialize the dead_pool structure */			    /* Initialize the dead_pool structure */
#ifdef HAVE_INET_ATON						#ifdef HAVE_INET_ATON
    inet_aton(sockshost, &socks_server);			    inet_aton(sockshost, &socks_server);
#elif defined(HAVE_INET_ADDR)					#elif defined(HAVE_INET_ADDR)
    socks_server.s_addr = inet_addr(sockshost);			    socks_server.s_addr = inet_addr(sockshost);
#endif								#endif
    newpool->sockshost = ntohl(socks_server.s_addr);		    newpool->sockshost = ntohl(socks_server.s_addr);
    newpool->socksport = socksport;				    newpool->socksport = socksport;
    newpool->deadrange_base = ntohl(deadrange_base.s_addr);	    newpool->deadrange_base = ntohl(deadrange_base.s_addr);
    newpool->deadrange_mask = ntohl(deadrange_mask.s_addr);	    newpool->deadrange_mask = ntohl(deadrange_mask.s_addr);
    newpool->deadrange_size = deadrange_size;			    newpool->deadrange_size = deadrange_size;
    newpool->write_pos = 0;					    newpool->write_pos = 0;
    newpool->dead_pos = 0;					    newpool->dead_pos = 0;
    newpool->n_entries = pool_size;				    newpool->n_entries = pool_size;

    /* Allocate space for the entries */			    /* Allocate space for the entries */
    newpool->entries = (pool_ent *) mmap(0, newpool->n_entrie	    newpool->entries = (pool_ent *) mmap(0, newpool->n_entrie
                            PROT_READ | PROT_WRITE, 		                            PROT_READ | PROT_WRITE, 
                            MAP_SHARED | MAP_ANONYMOUS, -1, 0	                            MAP_SHARED | MAP_ANONYMOUS, -1, 0
    if(!newpool->entries) {					    if(!newpool->entries) {
        munmap((void *)newpool, sizeof(dead_pool));		        munmap((void *)newpool, sizeof(dead_pool));
        show_msg(MSGERR, "init_pool: unable to mmap deadpool 	        show_msg(MSGERR, "init_pool: unable to mmap deadpool 
                 "(tried to map %d bytes)\n", 			                 "(tried to map %d bytes)\n", 
                 newpool->n_entries * sizeof(pool_ent)); 	                 newpool->n_entries * sizeof(pool_ent)); 
        return NULL;						        return NULL;
    }								    }

    /* Initialize the entries */				    /* Initialize the entries */
    for(i=0; i < newpool->n_entries; i++) {			    for(i=0; i < newpool->n_entries; i++) {
        newpool->entries[i].ip = -1;				        newpool->entries[i].ip = -1;
        newpool->entries[i].name[0] = '\0';			        newpool->entries[i].name[0] = '\0';
    }								    }

    return newpool;						    return newpool;
}								}

int 								int 
is_dead_address(dead_pool *pool, uint32_t addr) 		is_dead_address(dead_pool *pool, uint32_t addr) 
{								{
    uint32_t haddr = ntohl(addr);				    uint32_t haddr = ntohl(addr);
    if(pool == NULL) {						    if(pool == NULL) {
        return 0;						        return 0;
    }								    }
    return (pool->deadrange_base == (haddr & pool->deadrange_	    return (pool->deadrange_base == (haddr & pool->deadrange_
}								}

void								void
get_next_dead_address(dead_pool *pool, uint32_t *result)	get_next_dead_address(dead_pool *pool, uint32_t *result)
{								{
    *result = htonl(pool->deadrange_base + pool->dead_pos++);	    *result = htonl(pool->deadrange_base + pool->dead_pos++);
    if(pool->dead_pos >= pool->deadrange_size) {		    if(pool->dead_pos >= pool->deadrange_size) {
        pool->dead_pos = 0;					        pool->dead_pos = 0;
    }								    }
}								}

int 								int 
store_pool_entry(dead_pool *pool, char *hostname, struct in_a	store_pool_entry(dead_pool *pool, char *hostname, struct in_a
{								{
  int position = pool->write_pos;				  int position = pool->write_pos;
  int oldpos;							  int oldpos;
  int rc;							  int rc;
  uint32_t intaddr;						  uint32_t intaddr;

  show_msg(MSGDEBUG, "store_pool_entry: storing '%s'\n", host	  show_msg(MSGDEBUG, "store_pool_entry: storing '%s'\n", host
  show_msg(MSGDEBUG, "store_pool_entry: write pos is: %d\n", 	  show_msg(MSGDEBUG, "store_pool_entry: write pos is: %d\n", 

  /* Check to see if name already exists in pool */		  /* Check to see if name already exists in pool */
  oldpos = search_pool_for_name(pool, hostname);		  oldpos = search_pool_for_name(pool, hostname);
  if(oldpos != -1){						  if(oldpos != -1){
      show_msg(MSGDEBUG, "store_pool_entry: not storing (entr	      show_msg(MSGDEBUG, "store_pool_entry: not storing (entr
      addr->s_addr = pool->entries[oldpos].ip;			      addr->s_addr = pool->entries[oldpos].ip;
      return oldpos;						      return oldpos;
  }								  }

  /* If this is a .onion host, then we return a bogus ip from	  /* If this is a .onion host, then we return a bogus ip from
     otherwise we try to resolve it and store the 'real' IP *	     otherwise we try to resolve it and store the 'real' IP *
  if(strcasecmpend(hostname, ".onion") == 0) {			  if(strcasecmpend(hostname, ".onion") == 0) {
      get_next_dead_address(pool, &pool->entries[position].ip	      get_next_dead_address(pool, &pool->entries[position].ip
  } else {							  } else {
      rc = do_resolve(hostname, pool->sockshost, pool->socksp	      rc = do_resolve(hostname, pool->sockshost, pool->socksp
      if(rc != 0) {						      if(rc != 0) {
          show_msg(MSGWARN, "failed to resolve: %s\n", hostna	          show_msg(MSGWARN, "failed to resolve: %s\n", hostna
          return -1;						          return -1;
      } 							      } 
      if(is_dead_address(pool, intaddr)) {			      if(is_dead_address(pool, intaddr)) {
          show_msg(MSGERR, "resolved %s -> %d (deadpool addre	          show_msg(MSGERR, "resolved %s -> %d (deadpool addre
          return -1;						          return -1;
      }								      }
      pool->entries[position].ip = intaddr;			      pool->entries[position].ip = intaddr;
  }								  }

  strncpy(pool->entries[position].name, hostname, 255);		  strncpy(pool->entries[position].name, hostname, 255);
  pool->entries[position].name[255] = '\0';			  pool->entries[position].name[255] = '\0';
  pool->write_pos++;						  pool->write_pos++;
  if(pool->write_pos >= pool->n_entries) {			  if(pool->write_pos >= pool->n_entries) {
      pool->write_pos = 0;					      pool->write_pos = 0;
  }								  }
  addr->s_addr = pool->entries[position].ip;			  addr->s_addr = pool->entries[position].ip;

  show_msg(MSGDEBUG, "store_pool_entry: stored entry in slot 	  show_msg(MSGDEBUG, "store_pool_entry: stored entry in slot 

  return position;						  return position;
}								}

int 								int 
search_pool_for_name(dead_pool *pool, const char *name) 	search_pool_for_name(dead_pool *pool, const char *name) 
{								{
  int i;						      |	  unsigned int i;
  for(i=0; i < pool->n_entries; i++){				  for(i=0; i < pool->n_entries; i++){
    if(strcmp(name, pool->entries[i].name) == 0){		    if(strcmp(name, pool->entries[i].name) == 0){
      return i;							      return i;
    }								    }
  }								  }
  return -1;							  return -1;
}								}

char *								char *
get_pool_entry(dead_pool *pool, struct in_addr *addr)		get_pool_entry(dead_pool *pool, struct in_addr *addr)
{								{
  int i;						      |	  unsigned int i;
  uint32_t intaddr = addr->s_addr;				  uint32_t intaddr = addr->s_addr;

  if(pool == NULL) {						  if(pool == NULL) {
      return NULL;						      return NULL;
  }								  }

  show_msg(MSGDEBUG, "get_pool_entry: searching for: %s\n", i	  show_msg(MSGDEBUG, "get_pool_entry: searching for: %s\n", i
  for(i=0; i<pool->n_entries; i++) {				  for(i=0; i<pool->n_entries; i++) {
    if(intaddr == pool->entries[i].ip) {			    if(intaddr == pool->entries[i].ip) {
        show_msg(MSGDEBUG, "get_pool_entry: found: %s\n", poo	        show_msg(MSGDEBUG, "get_pool_entry: found: %s\n", poo
        return pool->entries[i].name;				        return pool->entries[i].name;
    }								    }
  }								  }
  show_msg(MSGDEBUG, "get_pool_entry: address not found\n");	  show_msg(MSGDEBUG, "get_pool_entry: address not found\n");

  return NULL;							  return NULL;
}								}

static int							static int
build_socks4a_resolve_request(char **out,			build_socks4a_resolve_request(char **out,
                              const char *username,		                              const char *username,
                              const char *hostname)		                              const char *hostname)
{								{
  size_t len;							  size_t len;
  uint16_t port = htons(0);  /* port: 0. */			  uint16_t port = htons(0);  /* port: 0. */
  uint32_t addr = htonl(0x00000001u); /* addr: 0.0.0.1 */	  uint32_t addr = htonl(0x00000001u); /* addr: 0.0.0.1 */

  len = 8 + strlen(username) + 1 + strlen(hostname) + 1;	  len = 8 + strlen(username) + 1 + strlen(hostname) + 1;
  *out = malloc(len);						  *out = malloc(len);
  (*out)[0] = 4;      /* SOCKS version 4 */			  (*out)[0] = 4;      /* SOCKS version 4 */
  (*out)[1] = '\xF0'; /* Command: resolve. */			  (*out)[1] = '\xF0'; /* Command: resolve. */

  memcpy((*out)+2, &port, sizeof(port));			  memcpy((*out)+2, &port, sizeof(port));
  memcpy((*out)+4, &addr, sizeof(addr));			  memcpy((*out)+4, &addr, sizeof(addr));
  strcpy((*out)+8, username);					  strcpy((*out)+8, username);
  strcpy((*out)+8+strlen(username)+1, hostname);		  strcpy((*out)+8+strlen(username)+1, hostname);

  return len;							  return len;
}								}

#define RESPONSE_LEN 8						#define RESPONSE_LEN 8

static int							static int
parse_socks4a_resolve_response(const char *response, size_t l	parse_socks4a_resolve_response(const char *response, size_t l
                               uint32_t *addr_out)		                               uint32_t *addr_out)
{								{
  uint8_t status;						  uint8_t status;
  uint16_t port;						  uint16_t port;

  if (len < RESPONSE_LEN) {					  if (len < RESPONSE_LEN) {
    show_msg(MSGWARN,"Truncated socks response.\n"); 		    show_msg(MSGWARN,"Truncated socks response.\n"); 
    return -1;							    return -1;
  }								  }
  if (((uint8_t)response[0])!=0) { /* version: 0 */		  if (((uint8_t)response[0])!=0) { /* version: 0 */
    show_msg(MSGWARN,"Nonzero version in socks response: bad 	    show_msg(MSGWARN,"Nonzero version in socks response: bad 
    return -1;							    return -1;
  }								  }
  status = (uint8_t)response[1];				  status = (uint8_t)response[1];

  memcpy(&port, response+2, sizeof(port));			  memcpy(&port, response+2, sizeof(port));
  if (port!=0) { /* port: 0 */					  if (port!=0) { /* port: 0 */
    show_msg(MSGWARN,"Nonzero port in socks response: bad for	    show_msg(MSGWARN,"Nonzero port in socks response: bad for
    return -1;							    return -1;
  }								  }
  if (status != 90) {						  if (status != 90) {
    show_msg(MSGWARN,"Bad status: socks request failed.\n"); 	    show_msg(MSGWARN,"Bad status: socks request failed.\n"); 
    return -1;							    return -1;
  }								  }

  memcpy(addr_out, response+4, sizeof(*addr_out));		  memcpy(addr_out, response+4, sizeof(*addr_out));

  return 0;							  return 0;
}								}

static int							static int
do_resolve(const char *hostname, uint32_t sockshost, uint16_t	do_resolve(const char *hostname, uint32_t sockshost, uint16_t
           uint32_t *result_addr)				           uint32_t *result_addr)
{								{
  int s;							  int s;
  struct sockaddr_in socksaddr;					  struct sockaddr_in socksaddr;
  char *req, *cp;						  char *req, *cp;
  int r, len;							  int r, len;
  char response_buf[RESPONSE_LEN];				  char response_buf[RESPONSE_LEN];

  show_msg(MSGDEBUG, "do_resolve: resolving %s\n", hostname);	  show_msg(MSGDEBUG, "do_resolve: resolving %s\n", hostname);

  s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);		  s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (s<0) {							  if (s<0) {
    show_msg(MSGWARN, "do_resolve: problem creating socket\n"	    show_msg(MSGWARN, "do_resolve: problem creating socket\n"
    return -1;							    return -1;
  }								  }

  memset(&socksaddr, 0, sizeof(socksaddr));			  memset(&socksaddr, 0, sizeof(socksaddr));
  socksaddr.sin_family = AF_INET;				  socksaddr.sin_family = AF_INET;
  socksaddr.sin_port = htons(socksport);			  socksaddr.sin_port = htons(socksport);
  socksaddr.sin_addr.s_addr = htonl(sockshost);			  socksaddr.sin_addr.s_addr = htonl(sockshost);
  if (realconnect(s, (struct sockaddr*)&socksaddr, sizeof(soc	  if (realconnect(s, (struct sockaddr*)&socksaddr, sizeof(soc
    show_msg(MSGWARN, "do_resolve: error connecting to SOCKS 	    show_msg(MSGWARN, "do_resolve: error connecting to SOCKS 
    return -1;							    return -1;
  }								  }

  if ((len = build_socks4a_resolve_request(&req, "", hostname	  if ((len = build_socks4a_resolve_request(&req, "", hostname
    show_msg(MSGWARN, "do_resolve: error generating SOCKS req	    show_msg(MSGWARN, "do_resolve: error generating SOCKS req
    return -1;							    return -1;
  }								  }

  cp = req;							  cp = req;
  while (len) {							  while (len) {
    r = send(s, cp, len, 0);					    r = send(s, cp, len, 0);
    if (r<0) {							    if (r<0) {
      show_msg(MSGWARN, "do_resolve: error sending SOCKS requ	      show_msg(MSGWARN, "do_resolve: error sending SOCKS requ
      free(req);						      free(req);
      return -1;						      return -1;
    }								    }
    len -= r;							    len -= r;
    cp += r;							    cp += r;
  }								  }
  free(req);							  free(req);

  len = 0;							  len = 0;
  while (len < RESPONSE_LEN) {					  while (len < RESPONSE_LEN) {
    r = recv(s, response_buf+len, RESPONSE_LEN-len, 0);		    r = recv(s, response_buf+len, RESPONSE_LEN-len, 0);
    if (r==0) {							    if (r==0) {
      show_msg(MSGWARN, "do_resolve: EOF while reading SOCKS 	      show_msg(MSGWARN, "do_resolve: EOF while reading SOCKS 
      return -1;						      return -1;
    }								    }
    if (r<0) {							    if (r<0) {
      show_msg(MSGWARN, "do_resolve: error reading SOCKS resp	      show_msg(MSGWARN, "do_resolve: error reading SOCKS resp
      return -1;						      return -1;
    }								    }
    len += r;							    len += r;
  }								  }

  realclose(s);							  realclose(s);

  if (parse_socks4a_resolve_response(response_buf, RESPONSE_L	  if (parse_socks4a_resolve_response(response_buf, RESPONSE_L
    show_msg(MSGWARN, "do_resolve: error parsing SOCKS respon	    show_msg(MSGWARN, "do_resolve: error parsing SOCKS respon
    return -1;							    return -1;
  }								  }

  show_msg(MSGDEBUG, "do_resolve: success\n");			  show_msg(MSGDEBUG, "do_resolve: success\n");

  return 0;							  return 0;
}								}

struct hostent *						struct hostent *
our_gethostbyname(dead_pool *pool, const char *name)		our_gethostbyname(dead_pool *pool, const char *name)
{								{
  int pos;							  int pos;
  static struct in_addr addr;					  static struct in_addr addr;
  static struct hostent he;					  static struct hostent he;
  static char *addrs[2];					  static char *addrs[2];

  show_msg(MSGDEBUG, "our_gethostbyname: '%s' requested\n", n	  show_msg(MSGDEBUG, "our_gethostbyname: '%s' requested\n", n

  pos = store_pool_entry(pool,(char *) name, &addr);		  pos = store_pool_entry(pool,(char *) name, &addr);
  if(pos == -1) {						  if(pos == -1) {
      h_errno = HOST_NOT_FOUND;					      h_errno = HOST_NOT_FOUND;
      return NULL;						      return NULL;
  }								  }

  addrs[0] = (char *)&addr;					  addrs[0] = (char *)&addr;
  addrs[1] = NULL;						  addrs[1] = NULL;

  he.h_name      = pool->entries[pos].name;			  he.h_name      = pool->entries[pos].name;
  he.h_aliases   = NULL;					  he.h_aliases   = NULL;
  he.h_length    = 4;						  he.h_length    = 4;
  he.h_addrtype  = AF_INET;					  he.h_addrtype  = AF_INET;
  he.h_addr_list = addrs;					  he.h_addr_list = addrs;

  show_msg(MSGDEBUG, "our_gethostbyname: resolved '%s' to: '%	  show_msg(MSGDEBUG, "our_gethostbyname: resolved '%s' to: '%
           name, inet_ntoa(*((struct in_addr *)he.h_addr)));	           name, inet_ntoa(*((struct in_addr *)he.h_addr)));

  return &he;							  return &he;
}								}

static struct hostent *						static struct hostent *
alloc_hostent(int af)						alloc_hostent(int af)
{								{
    struct hostent *he = NULL;					    struct hostent *he = NULL;
    char **addr_list = NULL;					    char **addr_list = NULL;
    void *addr = NULL;						    void *addr = NULL;
    char **aliases = NULL;					    char **aliases = NULL;

    if(af != AF_INET && af != AF_INET6) {			    if(af != AF_INET && af != AF_INET6) {
        return NULL;						        return NULL;
    }								    }

    /* Since the memory we allocate here will be free'd by fr	    /* Since the memory we allocate here will be free'd by fr
       that function is opaque to us, it's likely that we'll 	       that function is opaque to us, it's likely that we'll 
       bit of memory here. */					       bit of memory here. */

    he = malloc(sizeof(struct hostent));			    he = malloc(sizeof(struct hostent));
    addr_list = malloc(2 * sizeof(char *));			    addr_list = malloc(2 * sizeof(char *));
    if(af == AF_INET6) {					    if(af == AF_INET6) {
        addr = malloc(sizeof(struct in6_addr));			        addr = malloc(sizeof(struct in6_addr));
    } else {							    } else {
        addr = malloc(sizeof(struct in_addr));			        addr = malloc(sizeof(struct in_addr));
    }								    }
    aliases = malloc(sizeof(char *));				    aliases = malloc(sizeof(char *));

    if(he == NULL || addr_list == NULL || addr == NULL || ali	    if(he == NULL || addr_list == NULL || addr == NULL || ali
        if(he)							        if(he)
            free(he);						            free(he);
        if(addr_list)						        if(addr_list)
            free(addr_list);					            free(addr_list);
        if(addr)						        if(addr)
            free(addr);						            free(addr);
        if(aliases)						        if(aliases)
            free(aliases);					            free(aliases);
    }								    }

    he->h_name = NULL;						    he->h_name = NULL;
    he->h_addr_list = addr_list;				    he->h_addr_list = addr_list;
    he->h_addr_list[0] = addr;					    he->h_addr_list[0] = addr;
    he->h_addr_list[1] = NULL;					    he->h_addr_list[1] = NULL;
    he->h_aliases = aliases;					    he->h_aliases = aliases;
    he->h_aliases[0] = NULL;					    he->h_aliases[0] = NULL;
    he->h_length = af == AF_INET ? 4 : 16;			    he->h_length = af == AF_INET ? 4 : 16;
    he->h_addrtype = af;					    he->h_addrtype = af;

    return he;							    return he;
}								}

/* On Linux, there's no freehostent() anymore; we might as we	/* On Linux, there's no freehostent() anymore; we might as we
   this ourselves. */						   this ourselves. */

static void							static void
free_hostent(struct hostent *he)				free_hostent(struct hostent *he)
{								{
    int i;							    int i;
    if(he->h_name) {						    if(he->h_name) {
        free(he->h_name);					        free(he->h_name);
    }								    }
    if(he->h_aliases) {						    if(he->h_aliases) {
        for(i=0; he->h_aliases[i] != NULL; i++) {		        for(i=0; he->h_aliases[i] != NULL; i++) {
            free(he->h_aliases[i]);				            free(he->h_aliases[i]);
        }							        }
        free(he->h_aliases);					        free(he->h_aliases);
    }								    }
    if(he->h_addr_list) {					    if(he->h_addr_list) {
        free(he->h_addr_list);					        free(he->h_addr_list);
    }								    }
    free(he);							    free(he);
}								}

int								int
our_getaddrinfo(dead_pool *pool, const char *node, const char	our_getaddrinfo(dead_pool *pool, const char *node, const char
                void *hints, void *res)				                void *hints, void *res)
{								{
    int pos;							    int pos;
    struct in_addr addr;					    struct in_addr addr;
    char *ipstr;						    char *ipstr;
    int ret;							    int ret;

    /* If "node" looks like a dotted-decimal ip address, then	    /* If "node" looks like a dotted-decimal ip address, then
       the real getaddrinfo; otherwise we'll need to get an a	       the real getaddrinfo; otherwise we'll need to get an a
       our pool. */						       our pool. */

    /* TODO: work out what to do with AF_INET6 requests */	    /* TODO: work out what to do with AF_INET6 requests */

#ifdef HAVE_INET_ATON						#ifdef HAVE_INET_ATON
    if(inet_aton(node, &addr) == 0) {				    if(inet_aton(node, &addr) == 0) {
#elif defined(HAVE_INET_ADDR)					#elif defined(HAVE_INET_ADDR)
    /* If we're stuck with inet_addr, then getaddrinfo() won'	    /* If we're stuck with inet_addr, then getaddrinfo() won'
       properly with 255.255.255.255 (= -1).  There's not muc	       properly with 255.255.255.255 (= -1).  There's not muc
       do about this */						       do about this */
    in_addr_t is_valid;						    in_addr_t is_valid;
    is_valid = inet_addr(node);					    is_valid = inet_addr(node);
    if(is_valid == -1) {					    if(is_valid == -1) {
#endif								#endif
        pos = store_pool_entry(pool, (char *) node, &addr);	        pos = store_pool_entry(pool, (char *) node, &addr);
        if(pos == -1) {						        if(pos == -1) {
            return EAI_NONAME;					            return EAI_NONAME;
        } else {						        } else {
            ipstr = strdup(inet_ntoa(addr));			            ipstr = strdup(inet_ntoa(addr));
            ret = realgetaddrinfo(ipstr, service, hints, res)	            ret = realgetaddrinfo(ipstr, service, hints, res)
            free(ipstr);					            free(ipstr);
        }							        }
    } else {							    } else {
        ret = realgetaddrinfo(node, service, hints, res);	        ret = realgetaddrinfo(node, service, hints, res);
    }								    }

    return ret;							    return ret;
}								}

struct hostent *						struct hostent *
our_getipnodebyname(dead_pool *pool, const char *name, int af	our_getipnodebyname(dead_pool *pool, const char *name, int af
                    int *error_num)				                    int *error_num)
{								{
    int pos;							    int pos;
    struct hostent *he = NULL;					    struct hostent *he = NULL;
    int want_4in6 = 0;						    int want_4in6 = 0;
    char addr_convert_buf[80];					    char addr_convert_buf[80];
    struct in_addr pool_addr;					    struct in_addr pool_addr;

    if(af == AF_INET6) {					    if(af == AF_INET6) {
        /* Caller has requested an AF_INET6 address, and is n	        /* Caller has requested an AF_INET6 address, and is n
           accept IPv4-mapped IPV6 addresses. There's nothing	           accept IPv4-mapped IPV6 addresses. There's nothing
           service their request. */				           service their request. */
        if((flags & AI_V4MAPPED) == 0) {			        if((flags & AI_V4MAPPED) == 0) {
            show_msg(MSGWARN, "getipnodebyname: asked for V6 	            show_msg(MSGWARN, "getipnodebyname: asked for V6 
                     "but tsocks can't handle that\n");		                     "but tsocks can't handle that\n");
            *error_num = NO_RECOVERY;				            *error_num = NO_RECOVERY;
            return NULL;					            return NULL;
        } else {						        } else {
            want_4in6 = 1;					            want_4in6 = 1;
        }							        }
    }								    }

    pos = store_pool_entry(pool, (char *)name, &pool_addr);	    pos = store_pool_entry(pool, (char *)name, &pool_addr);
    if(pos == -1) {						    if(pos == -1) {
        *error_num = HOST_NOT_FOUND;				        *error_num = HOST_NOT_FOUND;
        return NULL;						        return NULL;
    }								    }

    he = alloc_hostent(af);					    he = alloc_hostent(af);
    if(he == NULL) {						    if(he == NULL) {
        show_msg(MSGERR, "getipnodebyname: failed to allocate	        show_msg(MSGERR, "getipnodebyname: failed to allocate
        *error_num = NO_RECOVERY;				        *error_num = NO_RECOVERY;
        return NULL;						        return NULL;
    }								    }

    if(want_4in6) {						    if(want_4in6) {
        /* Convert the ipv4 address in *addr to an IPv4 in IP	        /* Convert the ipv4 address in *addr to an IPv4 in IP
           address. TODO: inet_ntoa() is thread-safe on Solar	           address. TODO: inet_ntoa() is thread-safe on Solar
           not be on other platforms. */			           not be on other platforms. */
        strcpy(addr_convert_buf, "::FFFF:");			        strcpy(addr_convert_buf, "::FFFF:");
        strcpy(addr_convert_buf+7, inet_ntoa(pool_addr));	        strcpy(addr_convert_buf+7, inet_ntoa(pool_addr));
        if(inet_pton(AF_INET6, addr_convert_buf, he->h_addr_l	        if(inet_pton(AF_INET6, addr_convert_buf, he->h_addr_l
            show_msg(MSGERR, "getipnodebyname: inet_pton() fa	            show_msg(MSGERR, "getipnodebyname: inet_pton() fa
            free_hostent(he);					            free_hostent(he);
            *error_num = NO_RECOVERY;				            *error_num = NO_RECOVERY;
            return NULL;					            return NULL;
        }							        }
    } else {							    } else {
        ((struct in_addr *) he->h_addr_list[0])->s_addr = poo	        ((struct in_addr *) he->h_addr_list[0])->s_addr = poo
    }								    }
    he->h_name = strdup(name);					    he->h_name = strdup(name);

    return he;							    return he;
}								}


Only in /home/robert/Development/tork/src/tsocks/: dead_pool.c~
diff -y -x Makefile.am -x Makefile.in -x configure -x INSTALL -x README.TORDNS -x COPYING -x Changelog -x Doxyfile -x FAQ -x TODO ./dead_pool.h /home/robert/Development/tork/src/tsocks/dead_pool.h
#ifndef _DEAD_POOL_H						#ifndef _DEAD_POOL_H
#define _DEAD_POOL_H						#define _DEAD_POOL_H

#include <config.h>					      |	#include "../../config.h"

extern int (*realconnect)(CONNECT_SIGNATURE);			extern int (*realconnect)(CONNECT_SIGNATURE);
extern int (*realclose)(CLOSE_SIGNATURE);			extern int (*realclose)(CLOSE_SIGNATURE);
extern int (*realgetaddrinfo)(GETADDRINFO_SIGNATURE);		extern int (*realgetaddrinfo)(GETADDRINFO_SIGNATURE);

struct struct_pool_ent {					struct struct_pool_ent {
  unsigned int ip;						  unsigned int ip;
  char name[256];						  char name[256];
};								};

typedef struct struct_pool_ent pool_ent;			typedef struct struct_pool_ent pool_ent;

struct struct_dead_pool {					struct struct_dead_pool {
  pool_ent *entries;            /* Points to array of pool en	  pool_ent *entries;            /* Points to array of pool en
  int n_entries;                /* Number of entries in the d |	  unsigned int n_entries;       /* Number of entries in the d
  unsigned int deadrange_base;  /* Deadrange start IP in host	  unsigned int deadrange_base;  /* Deadrange start IP in host
  unsigned int deadrange_mask;  /* Deadrange netmask in host 	  unsigned int deadrange_mask;  /* Deadrange netmask in host 
  unsigned int deadrange_size;  /* Number of IPs in the deadr	  unsigned int deadrange_size;  /* Number of IPs in the deadr
  unsigned int write_pos;       /* Next position to use in th	  unsigned int write_pos;       /* Next position to use in th
  unsigned int dead_pos;        /* Next 'unused' deadpool IP 	  unsigned int dead_pos;        /* Next 'unused' deadpool IP 
  uint32_t sockshost;     					  uint32_t sockshost;     
  uint16_t socksport;						  uint16_t socksport;
  char pad[2];							  char pad[2];
};								};

typedef struct struct_dead_pool dead_pool;			typedef struct struct_dead_pool dead_pool;

dead_pool *init_pool(int deadpool_size, struct in_addr deadra |	dead_pool *init_pool(unsigned int deadpool_size, struct in_ad
    struct in_addr deadrange_mask, char *sockshost, uint16_t 	    struct in_addr deadrange_mask, char *sockshost, uint16_t 
int is_dead_address(dead_pool *pool, uint32_t addr);		int is_dead_address(dead_pool *pool, uint32_t addr);
char *get_pool_entry(dead_pool *pool, struct in_addr *addr);	char *get_pool_entry(dead_pool *pool, struct in_addr *addr);
int search_pool_for_name(dead_pool *pool, const char *name);	int search_pool_for_name(dead_pool *pool, const char *name);
struct hostent *our_gethostbyname(dead_pool *pool, const char	struct hostent *our_gethostbyname(dead_pool *pool, const char
int our_getaddrinfo(dead_pool *pool, const char *node, const 	int our_getaddrinfo(dead_pool *pool, const char *node, const 
    void *hints, void *res);					    void *hints, void *res);
struct hostent *our_getipnodebyname(dead_pool *pool, const ch	struct hostent *our_getipnodebyname(dead_pool *pool, const ch
    int af, int flags, int *error_num);				    int af, int flags, int *error_num);

#endif /* _DEAD_POOL_H */					#endif /* _DEAD_POOL_H */

Only in /home/robert/Development/tork/src/tsocks/: dead_pool.lo
Only in /home/robert/Development/tork/src/tsocks/: getpeername.patch
Only in /home/robert/Development/tork/src/tsocks/: infiniteloop.patch
diff -y -x Makefile.am -x Makefile.in -x configure -x INSTALL -x README.TORDNS -x COPYING -x Changelog -x Doxyfile -x FAQ -x TODO ./inspectsocks.c /home/robert/Development/tork/src/tsocks/inspectsocks.c
/*								/*

    INSPECTSOCKS - Part of the tsocks package			    INSPECTSOCKS - Part of the tsocks package
		   This utility can be used to determine the 			   This utility can be used to determine the 
		   level of a SOCKS server.					   level of a SOCKS server.

    Copyright (C) 2000 Shaun Clowes 				    Copyright (C) 2000 Shaun Clowes 

    This program is free software; you can redistribute it an	    This program is free software; you can redistribute it an
    it under the terms of the GNU General Public License as p	    it under the terms of the GNU General Public License as p
    the Free Software Foundation; either version 2 of the Lic	    the Free Software Foundation; either version 2 of the Lic
    (at your option) any later version.				    (at your option) any later version.

    This program is distributed in the hope that it will be u	    This program is distributed in the hope that it will be u
    but WITHOUT ANY WARRANTY; without even the implied warran	    but WITHOUT ANY WARRANTY; without even the implied warran
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    GNU General Public License for more details.		    GNU General Public License for more details.

    You should have received a copy of the GNU General Public	    You should have received a copy of the GNU General Public
    along with this program; if not, write to the Free Softwa	    along with this program; if not, write to the Free Softwa
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.	    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

*/								*/

/* Global configuration variables */ 				/* Global configuration variables */ 
char *progname = "inspectsocks";	   /* Name for error  |	const char *progname = "inspectsocks";	   /* Name for error 
int defaultport	= 1080;			   /* Default SOCKS p	int defaultport	= 1080;			   /* Default SOCKS p

/* Header Files */						/* Header Files */
#include <config.h>					      |	#include "../../config.h"
#include <stdio.h>						#include <stdio.h>
#include <stdlib.h>						#include <stdlib.h>
#include <unistd.h>						#include <unistd.h>
#include <sys/types.h>						#include <sys/types.h>
#include <sys/socket.h>						#include <sys/socket.h>
#include <string.h>						#include <string.h>
#include <strings.h>						#include <strings.h>
							      >	#include <sys/types.h>
#include <netinet/in.h>						#include <netinet/in.h>
#include <arpa/inet.h>						#include <arpa/inet.h>
#include <errno.h>						#include <errno.h>
#include <common.h>						#include <common.h>

int send_request(struct sockaddr_in *server, void *req, 	int send_request(struct sockaddr_in *server, void *req, 
                 int reqlen, void *rep, int replen);		                 int reqlen, void *rep, int replen);

int main(int argc, char *argv[]) {				int main(int argc, char *argv[]) {
	char *usage = "Usage: <socks server name/ip> [portno] |		const char *usage = "Usage: <socks server name/ip> [p
	char req[9];							char req[9];
	char resp[100];							char resp[100];
	unsigned short int portno = defaultport;			unsigned short int portno = defaultport;
	int ver = 0;							int ver = 0;
	int read_bytes;							int read_bytes;
	struct sockaddr_in server;					struct sockaddr_in server;

	if ((argc < 2) || (argc > 3)) {					if ((argc < 2) || (argc > 3)) {
		show_msg(MSGERR, "Invalid number of arguments			show_msg(MSGERR, "Invalid number of arguments
		show_msg(MSGERR, "%s\n", usage);				show_msg(MSGERR, "%s\n", usage);
		exit(1);							exit(1);
	}								}

	switch (argc) {							switch (argc) {
		case 3:								case 3:
			portno = (unsigned short int)					portno = (unsigned short int)
				 strtol(argv[2], (char **) 0,					 strtol(argv[2], (char **) 0,
			if ((portno == 0) || (errno == EINVAL				if ((portno == 0) || (errno == EINVAL
				show_msg(MSGERR, "%s\n", usag					show_msg(MSGERR, "%s\n", usag
				exit(1);							exit(1);
			}								}
		case 2:								case 2:
			if ((server.sin_addr.s_addr = resolve				if ((server.sin_addr.s_addr = resolve
                            ==  -1) {			      |	                            ==  0) {
				show_msg(MSGERR, "Invalid IP/					show_msg(MSGERR, "Invalid IP/
				show_msg(MSGERR, "%s\n", usag					show_msg(MSGERR, "%s\n", usag
				exit(1);							exit(1);
			}								}
	}								}

	server.sin_family = AF_INET; /* host byte order */		server.sin_family = AF_INET; /* host byte order */
	server.sin_port = htons(portno);     /* short, networ		server.sin_port = htons(portno);     /* short, networ
	bzero(&(server.sin_zero), 8);/* zero the rest of the 		bzero(&(server.sin_zero), 8);/* zero the rest of the 

	/* Now, we send a SOCKS V5 request which happens to b		/* Now, we send a SOCKS V5 request which happens to b
	/* the same size as the smallest possible SOCKS V4   		/* the same size as the smallest possible SOCKS V4   
	/* request. In this packet we specify we have 7 auth 		/* request. In this packet we specify we have 7 auth 
	/* methods but specify them all as NO AUTH.          		/* methods but specify them all as NO AUTH.          
	bzero(req, sizeof(req));					bzero(req, sizeof(req));
	req[0] = '\x05';						req[0] = '\x05';
	req[1] = '\x07';						req[1] = '\x07';
	read_bytes = send_request(&server, req, 			read_bytes = send_request(&server, req, 
				  sizeof(req), resp, sizeof(r					  sizeof(req), resp, sizeof(r
	if (read_bytes > 0) {						if (read_bytes > 0) {
		if ((int) resp[0] == 0) {					if ((int) resp[0] == 0) {
			ver = 4;							ver = 4;
		} else if ((int) resp[0] == 5) {				} else if ((int) resp[0] == 5) {
			ver = 5;							ver = 5;
		} 								} 
		if (ver != 0) {							if (ver != 0) {
			printf("Reply indicates server is a v				printf("Reply indicates server is a v
			       "%d socks server\n", ver);				       "%d socks server\n", ver);
		} else {							} else {
			show_msg(MSGERR, "Invalid SOCKS versi				show_msg(MSGERR, "Invalid SOCKS versi
			       	   "probably not a socks serv				       	   "probably not a socks serv
				   ver);							   ver);
		}								}
		exit(0);							exit(0);
	}								}	

	/* Hmmm.... disconnected so try a V4 request */			/* Hmmm.... disconnected so try a V4 request */
	printf("Server disconnected V5 request, trying V4\n")		printf("Server disconnected V5 request, trying V4\n")
	req[0] = '\x04';						req[0] = '\x04';
	req[1] = '\x01';						req[1] = '\x01';
	read_bytes = send_request(&server, req, 			read_bytes = send_request(&server, req, 
				  sizeof(req), resp, sizeof(r					  sizeof(req), resp, sizeof(r
	if (read_bytes > 0) {						if (read_bytes > 0) {
		if ((int) resp[0] == 0) {					if ((int) resp[0] == 0) {
			ver = 4;							ver = 4;
		} 								} 
		if (ver == 4) {							if (ver == 4) {
			printf("Reply indicates server is a v				printf("Reply indicates server is a v
			       "4 socks server\n");					       "4 socks server\n");
		} else {							} else {
			show_msg(MSGERR, "Invalid SOCKS versi				show_msg(MSGERR, "Invalid SOCKS versi
			       	   "probably not a socks serv				       	   "probably not a socks serv
				   (int) resp[0]);						   (int) resp[0]);
		}								}
		exit(0);							exit(0);
	} else {							} else {
		show_msg(MSGERR, "Server disconnected, probab			show_msg(MSGERR, "Server disconnected, probab
			   "socks server\n");						   "socks server\n");
	}								}

	return(0);  							return(0);  
}								}

int send_request(struct sockaddr_in *server, void *req, 	int send_request(struct sockaddr_in *server, void *req, 
		 int reqlen, void *rep, int replen) {				 int reqlen, void *rep, int replen) {
	int sock;							int sock;
	int rc;								int rc;

	if ((sock = socket(server->sin_family, SOCK_STREAM, 0		if ((sock = socket(server->sin_family, SOCK_STREAM, 0
	{								{
		show_msg(MSGERR, "Could not create socket (%s			show_msg(MSGERR, "Could not create socket (%s
			   strerror(errno));						   strerror(errno));
		exit(1);							exit(1);
	}								}
									
	if (connect(sock, (struct sockaddr *) server,			if (connect(sock, (struct sockaddr *) server,
		    sizeof(struct sockaddr_in)) != -1) {			    sizeof(struct sockaddr_in)) != -1) {
	} else {							} else {
		show_msg(MSGERR, "Connect failed! (%s)\n",			show_msg(MSGERR, "Connect failed! (%s)\n",
			   strerror(errno));						   strerror(errno));
		exit(1);							exit(1);
	}								}

	if (send(sock, (void *) req, reqlen,0) < 0) {			if (send(sock, (void *) req, reqlen,0) < 0) {
		show_msg(MSGERR, "Could not send to server (%			show_msg(MSGERR, "Could not send to server (%
			   strerror(errno));						   strerror(errno));
		exit(1);							exit(1);
	}								}

	/* Now wait for reply */					/* Now wait for reply */
	if ((rc = recv(sock, (void *) rep, replen, 0)) < 0) {		if ((rc = recv(sock, (void *) rep, replen, 0)) < 0) {
		show_msg(MSGERR, "Could not read from server\			show_msg(MSGERR, "Could not read from server\
			   strerror(errno));						   strerror(errno));
		exit(1);							exit(1);
	}								}

	close(sock);							close(sock);

	return(rc);							return(rc);
									
}								}
Only in /home/robert/Development/tork/src/tsocks/: inspectsocks.c~
diff -y -x Makefile.am -x Makefile.in -x configure -x INSTALL -x README.TORDNS -x COPYING -x Changelog -x Doxyfile -x FAQ -x TODO ./install-sh /home/robert/Development/tork/src/tsocks/install-sh
#! /bin/sh							#! /bin/sh
#								#
# install - install a program, script, or datafile		# install - install a program, script, or datafile
# This comes from X11R5.					# This comes from X11R5.
#								#
# Calling this script install-sh is preferred over install.sh	# Calling this script install-sh is preferred over install.sh
# `make' implicit rules from creating a file called install f	# `make' implicit rules from creating a file called install f
# when there is no Makefile.					# when there is no Makefile.
#								#
# This script is compatible with the BSD install script, but 	# This script is compatible with the BSD install script, but 
# from scratch.							# from scratch.
#								#


# set DOITPROG to echo to test this script			# set DOITPROG to echo to test this script

# Don't use :- since 4.3BSD and earlier shells don't like it.	# Don't use :- since 4.3BSD and earlier shells don't like it.
doit="${DOITPROG-}"						doit="${DOITPROG-}"


# put in absolute paths if you don't have them in your path; 	# put in absolute paths if you don't have them in your path; 

mvprog="${MVPROG-mv}"						mvprog="${MVPROG-mv}"
cpprog="${CPPROG-cp}"						cpprog="${CPPROG-cp}"
chmodprog="${CHMODPROG-chmod}"					chmodprog="${CHMODPROG-chmod}"
chownprog="${CHOWNPROG-chown}"					chownprog="${CHOWNPROG-chown}"
chgrpprog="${CHGRPPROG-chgrp}"					chgrpprog="${CHGRPPROG-chgrp}"
stripprog="${STRIPPROG-strip}"					stripprog="${STRIPPROG-strip}"
rmprog="${RMPROG-rm}"						rmprog="${RMPROG-rm}"
mkdirprog="${MKDIRPROG-mkdir}"					mkdirprog="${MKDIRPROG-mkdir}"

tranformbasename=""						tranformbasename=""
transform_arg=""						transform_arg=""
instcmd="$mvprog"						instcmd="$mvprog"
chmodcmd="$chmodprog 0755"					chmodcmd="$chmodprog 0755"
chowncmd=""							chowncmd=""
chgrpcmd=""							chgrpcmd=""
stripcmd=""							stripcmd=""
rmcmd="$rmprog -f"						rmcmd="$rmprog -f"
mvcmd="$mvprog"							mvcmd="$mvprog"
src=""								src=""
dst=""								dst=""
dir_arg=""							dir_arg=""

while [ x"$1" != x ]; do					while [ x"$1" != x ]; do
    case $1 in							    case $1 in
	-c) instcmd="$cpprog"						-c) instcmd="$cpprog"
	    shift							    shift
	    continue;;							    continue;;

	-d) dir_arg=true						-d) dir_arg=true
	    shift							    shift
	    continue;;							    continue;;

	-m) chmodcmd="$chmodprog $2"					-m) chmodcmd="$chmodprog $2"
	    shift							    shift
	    shift							    shift
	    continue;;							    continue;;

	-o) chowncmd="$chownprog $2"					-o) chowncmd="$chownprog $2"
	    shift							    shift
	    shift							    shift
	    continue;;							    continue;;

	-g) chgrpcmd="$chgrpprog $2"					-g) chgrpcmd="$chgrpprog $2"
	    shift							    shift
	    shift							    shift
	    continue;;							    continue;;

	-s) stripcmd="$stripprog"					-s) stripcmd="$stripprog"
	    shift							    shift
	    continue;;							    continue;;

	-t=*) transformarg=`echo $1 | sed 's/-t=//'`			-t=*) transformarg=`echo $1 | sed 's/-t=//'`
	    shift							    shift
	    continue;;							    continue;;

	-b=*) transformbasename=`echo $1 | sed 's/-b=//'`		-b=*) transformbasename=`echo $1 | sed 's/-b=//'`
	    shift							    shift
	    continue;;							    continue;;

	*)  if [ x"$src" = x ]						*)  if [ x"$src" = x ]
	    then							    then
		src=$1								src=$1
	    else							    else
		# this colon is to work around a 386BSD /bin/			# this colon is to work around a 386BSD /bin/
		:								:
		dst=$1								dst=$1
	    fi								    fi
	    shift							    shift
	    continue;;							    continue;;
    esac							    esac
done								done

if [ x"$src" = x ]						if [ x"$src" = x ]
then								then
	echo "install:	no input file specified"			echo "install:	no input file specified"
	exit 1								exit 1
else								else
	true								true
fi								fi

if [ x"$dir_arg" != x ]; then					if [ x"$dir_arg" != x ]; then
	dst=$src							dst=$src
	src=""								src=""
									
	if [ -d $dst ]; then						if [ -d $dst ]; then
		instcmd=:							instcmd=:
	else								else
		instcmd=mkdir							instcmd=mkdir
	fi								fi
else								else

# Waiting for this to be detected by the "$instcmd $src $dstt	# Waiting for this to be detected by the "$instcmd $src $dstt
# might cause directories to be created, which would be espec	# might cause directories to be created, which would be espec
# if $src (and thus $dsttmp) contains '*'.			# if $src (and thus $dsttmp) contains '*'.

	if [ -f $src -o -d $src ]					if [ -f $src -o -d $src ]
	then								then
		true								true
	else								else
		echo "install:  $src does not exist"				echo "install:  $src does not exist"
		exit 1								exit 1
	fi								fi
									
	if [ x"$dst" = x ]						if [ x"$dst" = x ]
	then								then
		echo "install:	no destination specified"			echo "install:	no destination specified"
		exit 1								exit 1
	else								else
		true								true
	fi								fi

# If destination is a directory, append the input filename; i	# If destination is a directory, append the input filename; i
# does not like double slashes in filenames, you may need to 	# does not like double slashes in filenames, you may need to 

	if [ -d $dst ]							if [ -d $dst ]
	then								then
		dst="$dst"/`basename $src`					dst="$dst"/`basename $src`
	else								else
		true								true
	fi								fi
fi								fi

## this sed command emulates the dirname command		## this sed command emulates the dirname command
dstdir=`echo $dst | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`		dstdir=`echo $dst | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`

# Make sure that the destination directory exists.		# Make sure that the destination directory exists.
#  this part is taken from Noah Friedman's mkinstalldirs scri	#  this part is taken from Noah Friedman's mkinstalldirs scri

# Skip lots of stat calls in the usual case.			# Skip lots of stat calls in the usual case.
if [ ! -d "$dstdir" ]; then					if [ ! -d "$dstdir" ]; then
defaultIFS='							defaultIFS='	
'								'
IFS="${IFS-${defaultIFS}}"					IFS="${IFS-${defaultIFS}}"

oIFS="${IFS}"							oIFS="${IFS}"
# Some sh's can't handle IFS=/ for some reason.			# Some sh's can't handle IFS=/ for some reason.
IFS='%'								IFS='%'
set - `echo ${dstdir} | sed -e 's@/@%@g' -e 's@^%@/@'`		set - `echo ${dstdir} | sed -e 's@/@%@g' -e 's@^%@/@'`
IFS="${oIFS}"							IFS="${oIFS}"

pathcomp=''							pathcomp=''

while [ $# -ne 0 ] ; do						while [ $# -ne 0 ] ; do
	pathcomp="${pathcomp}${1}"					pathcomp="${pathcomp}${1}"
	shift								shift

	if [ ! -d "${pathcomp}" ] ;					if [ ! -d "${pathcomp}" ] ;
        then							        then
		$mkdirprog "${pathcomp}"					$mkdirprog "${pathcomp}"
	else								else
		true								true
	fi								fi

	pathcomp="${pathcomp}/"						pathcomp="${pathcomp}/"
done								done
fi								fi

if [ x"$dir_arg" != x ]						if [ x"$dir_arg" != x ]
then								then
	$doit $instcmd $dst &&						$doit $instcmd $dst &&

	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dst; 		if [ x"$chowncmd" != x ]; then $doit $chowncmd $dst; 
	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dst; 		if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dst; 
	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dst; 		if [ x"$stripcmd" != x ]; then $doit $stripcmd $dst; 
	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dst; 		if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dst; 
else								else

# If we're going to rename the final executable, determine th	# If we're going to rename the final executable, determine th

	if [ x"$transformarg" = x ] 					if [ x"$transformarg" = x ] 
	then								then
		dstfile=`basename $dst`						dstfile=`basename $dst`
	else								else
		dstfile=`basename $dst $transformbasename | 			dstfile=`basename $dst $transformbasename | 
			sed $transformarg`$transformbasename				sed $transformarg`$transformbasename
	fi								fi

# don't allow the sed command to completely eliminate the fil	# don't allow the sed command to completely eliminate the fil

	if [ x"$dstfile" = x ] 						if [ x"$dstfile" = x ] 
	then								then
		dstfile=`basename $dst`						dstfile=`basename $dst`
	else								else
		true								true
	fi								fi

# Make a temp file name in the proper directory.		# Make a temp file name in the proper directory.

	dsttmp=$dstdir/#inst.$$#					dsttmp=$dstdir/#inst.$$#

# Move or copy the file name to the temp name			# Move or copy the file name to the temp name

	$doit $instcmd $src $dsttmp &&					$doit $instcmd $src $dsttmp &&

	trap "rm -f ${dsttmp}" 0 &&					trap "rm -f ${dsttmp}" 0 &&

# and set any options; do chmod last to preserve setuid bits	# and set any options; do chmod last to preserve setuid bits

# If any of these fail, we abort the whole thing.  If we want	# If any of these fail, we abort the whole thing.  If we want
# ignore errors from any of these, just make sure not to igno	# ignore errors from any of these, just make sure not to igno
# errors from the above "$doit $instcmd $src $dsttmp" command	# errors from the above "$doit $instcmd $src $dsttmp" command

	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dsttm		if [ x"$chowncmd" != x ]; then $doit $chowncmd $dsttm
	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dsttm		if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dsttm
	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dsttm		if [ x"$stripcmd" != x ]; then $doit $stripcmd $dsttm
	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dsttm		if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dsttm

# Now rename the file to the real destination.			# Now rename the file to the real destination.

	$doit $rmcmd -f $dstdir/$dstfile &&				$doit $rmcmd -f $dstdir/$dstfile &&
	$doit $mvcmd $dsttmp $dstdir/$dstfile 				$doit $mvcmd $dsttmp $dstdir/$dstfile 

fi &&								fi &&


exit 0								exit 0
Only in /home/robert/Development/tork/src/tsocks/: libtorksocks.la
diff -y -x Makefile.am -x Makefile.in -x configure -x INSTALL -x README.TORDNS -x COPYING -x Changelog -x Doxyfile -x FAQ -x TODO ./mkinstalldirs /home/robert/Development/tork/src/tsocks/mkinstalldirs
#! /bin/sh							#! /bin/sh
# mkinstalldirs --- make directory hierarchy			# mkinstalldirs --- make directory hierarchy
# Author: Noah Friedman <friedman@prep.ai.mit.edu>		# Author: Noah Friedman <friedman@prep.ai.mit.edu>
# Created: 1993-05-16						# Created: 1993-05-16
# Last modified: 1994-03-25					# Last modified: 1994-03-25
# Public domain							# Public domain

errstatus=0							errstatus=0

for file in ${1+"$@"} ; do 					for file in ${1+"$@"} ; do 
   set fnord `echo ":$file" | sed -ne 's/^:\//#/;s/^://;s/\//	   set fnord `echo ":$file" | sed -ne 's/^:\//#/;s/^://;s/\//
   shift							   shift

   pathcomp=							   pathcomp=
   for d in ${1+"$@"} ; do					   for d in ${1+"$@"} ; do
     pathcomp="$pathcomp$d"					     pathcomp="$pathcomp$d"
     case "$pathcomp" in					     case "$pathcomp" in
       -* ) pathcomp=./$pathcomp ;;				       -* ) pathcomp=./$pathcomp ;;
     esac							     esac

     if test ! -d "$pathcomp"; then				     if test ! -d "$pathcomp"; then
        echo "mkdir $pathcomp" 1>&2				        echo "mkdir $pathcomp" 1>&2
        mkdir "$pathcomp" > /dev/null 2>&1 || lasterr=$?	        mkdir "$pathcomp" > /dev/null 2>&1 || lasterr=$?
     fi								     fi

     if test ! -d "$pathcomp"; then				     if test ! -d "$pathcomp"; then
	errstatus=$lasterr						errstatus=$lasterr
     fi								     fi

     pathcomp="$pathcomp/"					     pathcomp="$pathcomp/"
   done								   done
done								done

exit $errstatus							exit $errstatus

# mkinstalldirs ends here					# mkinstalldirs ends here
diff -y -x Makefile.am -x Makefile.in -x configure -x INSTALL -x README.TORDNS -x COPYING -x Changelog -x Doxyfile -x FAQ -x TODO ./parser.c /home/robert/Development/tork/src/tsocks/parser.c
/*								/*

   parser.c    - Parsing routines for tsocks.conf		   parser.c    - Parsing routines for tsocks.conf

*/								*/

#include <sys/types.h>						#include <sys/types.h>
#include <netinet/in.h>						#include <netinet/in.h>
#include <sys/socket.h>						#include <sys/socket.h>
#include <arpa/inet.h>						#include <arpa/inet.h>
#include <string.h>						#include <string.h>
#include <stdio.h>						#include <stdio.h>
#include <stdlib.h>						#include <stdlib.h>
#include <errno.h>						#include <errno.h>
#include <config.h>					      |	#include "../../config.h"
#include "common.h"						#include "common.h"
#include "parser.h"						#include "parser.h"

/* Global configuration variables */				/* Global configuration variables */
#define MAXLINE         BUFSIZ             /* Max length of c	#define MAXLINE         BUFSIZ             /* Max length of c
static struct serverent *currentcontext = NULL;			static struct serverent *currentcontext = NULL;

static int handle_line(struct parsedfile *, char *, int);	static int handle_line(struct parsedfile *, char *, int);
static int check_server(struct serverent *);			static int check_server(struct serverent *);
static int tokenize(char *, int, char *[]);			static int tokenize(char *, int, char *[]);
static int handle_path(struct parsedfile *, int, int, char *[	static int handle_path(struct parsedfile *, int, int, char *[
static int handle_endpath(struct parsedfile *, int, int, char |	static int handle_endpath(struct parsedfile *, int, int);
static int handle_reaches(struct parsedfile *, int, char *);  |	static int handle_reaches(int, char *);
static int handle_server(struct parsedfile *, int, char *);	static int handle_server(struct parsedfile *, int, char *);
static int handle_type(struct parsedfile *config, int, char *	static int handle_type(struct parsedfile *config, int, char *
static int handle_port(struct parsedfile *config, int, char *	static int handle_port(struct parsedfile *config, int, char *
static int handle_local(struct parsedfile *, int, char *);    |	static int handle_local(struct parsedfile *, int, const char 
static int handle_tordns_enabled(struct parsedfile *, int, ch	static int handle_tordns_enabled(struct parsedfile *, int, ch
static int handle_tordns_deadpool_range(struct parsedfile *,  |	static int handle_tordns_deadpool_range(struct parsedfile *, 
static int handle_tordns_cache_size(struct parsedfile *, int, |	static int handle_tordns_cache_size(struct parsedfile *, char
static int handle_defuser(struct parsedfile *, int, char *);	static int handle_defuser(struct parsedfile *, int, char *);
static int handle_defpass(struct parsedfile *, int, char *);	static int handle_defpass(struct parsedfile *, int, char *);
static int make_netent(char *value, struct netent **ent);	static int make_netent(char *value, struct netent **ent);

int read_config (char *filename, struct parsedfile *config) {	int read_config (char *filename, struct parsedfile *config) {
	FILE *conf;							FILE *conf;
	char line[MAXLINE];						char line[MAXLINE];
	int rc = 0;							int rc = 0;
	int lineno = 1;							int lineno = 1;
	struct serverent *server;					struct serverent *server;

   /* Clear out the structure */				   /* Clear out the structure */
   memset(config, 0x0, sizeof(*config));			   memset(config, 0x0, sizeof(*config));

   /* Initialization */						   /* Initialization */
   currentcontext = &(config->defaultserver);			   currentcontext = &(config->defaultserver);

   /* Tordns defaults */					   /* Tordns defaults */
   config->tordns_cache_size = 256;				   config->tordns_cache_size = 256;
   config->tordns_enabled = 1;					   config->tordns_enabled = 1;

							      >
	/* If a filename wasn't provided, use the default */		/* If a filename wasn't provided, use the default */
	if (filename == NULL) {						if (filename == NULL) {
		strncpy(line, CONF_FILE, sizeof(line) - 1);			strncpy(line, CONF_FILE, sizeof(line) - 1);
		/* Insure null termination */					/* Insure null termination */
		line[sizeof(line) - 1] = (char) 0;				line[sizeof(line) - 1] = (char) 0;
		filename = line;						filename = line;
	}								}

	/* Read the configuration file */		      |		/* If there is no configuration file use reasonable d
	if ((conf = fopen(filename, "r")) == NULL) {			if ((conf = fopen(filename, "r")) == NULL) {
		show_msg(MSGERR, "Could not open socks config			show_msg(MSGERR, "Could not open socks config
			   "(%s), assuming all networks local				   "(%s), assuming all networks local
        handle_local(config, 0, "0.0.0.0/0.0.0.0");	      |	        memset(&(config->defaultserver), 0x0, sizeof(config->
							      >			check_server(&(config->defaultserver));
							      >			handle_local(config, 0, "127.0.0.0/255.0.0.0"
							      >	/*        handle_local(config, 0, "0.0.0.0/0.0.0.0");*/
		rc = 1; /* Severe errors reading configuratio			rc = 1; /* Severe errors reading configuratio
	}								}	
	else {								else {
      memset(&(config->defaultserver), 0x0, sizeof(config->de |
							      >	        memset(&(config->defaultserver), 0x0, sizeof(config->

		while (NULL != fgets(line, MAXLINE, conf)) {			while (NULL != fgets(line, MAXLINE, conf)) {
			/* This line _SHOULD_ end in \n so we				/* This line _SHOULD_ end in \n so we
			/* just chop off the \n and hand it o				/* just chop off the \n and hand it o
			if (strlen(line) > 0)						if (strlen(line) > 0)
				line[strlen(line) - 1] = '\0'					line[strlen(line) - 1] = '\0'
			handle_line(config, line, lineno);				handle_line(config, line, lineno);
			lineno++;							lineno++;
		} 								} 
		fclose(conf);							fclose(conf);

		if (!config->localnets) {		      |			/* Always add the 127.0.0.1/255.0.0.0 subnet 
                        /* Use 127.0.0.1/255.0.0.0 by default |			handle_local(config, 0, "127.0.0.0/255.0.0.0"
                        handle_local(config, 0, "127.0.0.0/25 <
                }					      <
							      <

		/* Check default server */					/* Check default server */
		check_server(&(config->defaultserver));				check_server(&(config->defaultserver));
		server = (config->paths);					server = (config->paths);
		while (server != NULL) {					while (server != NULL) {
			check_server(server);						check_server(server);
			server = server->next;						server = server->next;
		}								}
	}								}

    /* Initialize tordns deadpool_range if not supplied */	    /* Initialize tordns deadpool_range if not supplied */
    if(config->tordns_deadpool_range == NULL) {			    if(config->tordns_deadpool_range == NULL) {
        handle_tordns_deadpool_range(config, 0, "127.0.69.0/2	        handle_tordns_deadpool_range(config, 0, "127.0.69.0/2
    }								    }

	return(rc);							return(rc);
}								}

/* Check server entries (and establish defaults) */		/* Check server entries (and establish defaults) */
static int check_server(struct serverent *server) {		static int check_server(struct serverent *server) {

	/* Default to the default SOCKS port */		      |		/* Default to the default Tor Socks port */
	if (server->port == 0) {					if (server->port == 0) {
		server->port = 1080;			      |			server->port = 9050;
							      >		}
							      >
							      >		/* Default to a presumably local installation of Tor 
							      >		if (server->address == NULL) {
							      >			server->address = strdup("127.0.0.1");
	}								}

	/* Default to SOCKS V4 */					/* Default to SOCKS V4 */
	if (server->type == 0) {					if (server->type == 0) {
		server->type = 4;						server->type = 4;
	}								}

	return(0);							return(0);
}								}



static int handle_line(struct parsedfile *config, char *line,	static int handle_line(struct parsedfile *config, char *line,
	char *words[10];						char *words[10];
	static char savedline[MAXLINE];					static char savedline[MAXLINE];
	int   nowords = 0, i;						int   nowords = 0, i;

	/* Save the input string */					/* Save the input string */
	strncpy(savedline, line, MAXLINE - 1);				strncpy(savedline, line, MAXLINE - 1);
	savedline[MAXLINE - 1] = (char) 0;				savedline[MAXLINE - 1] = (char) 0;
	/* Tokenize the input string */					/* Tokenize the input string */
	nowords = tokenize(line, 10, words);				nowords = tokenize(line, 10, words);	

	/* Set the spare slots to an empty string to simplify		/* Set the spare slots to an empty string to simplify
	/* processing                                        		/* processing                                        
	for (i = nowords; i < 10; i++) 					for (i = nowords; i < 10; i++) 
		words[i] = "";				      |			words[i] = NULL;

	if (nowords > 0) {						if (nowords > 0) {
		/* Now this can either be a "path" block star			/* Now this can either be a "path" block star
		/* ender, otherwise it has to be a pair (<nam			/* ender, otherwise it has to be a pair (<nam
		/* <value>)                                  			/* <value>)                                  
		if (!strcmp(words[0], "path")) {				if (!strcmp(words[0], "path")) {
			handle_path(config, lineno, nowords, 				handle_path(config, lineno, nowords, 
		} else if (!strcmp(words[0], "}")) {				} else if (!strcmp(words[0], "}")) {
			handle_endpath(config, lineno, noword |				handle_endpath(config, lineno, noword
		} else {							} else {
			/* Has to be a pair */						/* Has to be a pair */
			if ((nowords != 3) || (strcmp(words[1				if ((nowords != 3) || (strcmp(words[1
				show_msg(MSGERR, "Malformed c					show_msg(MSGERR, "Malformed c
					   "on line %d in con						   "on line %d in con
					   "file, \"%s\"\n", 						   "file, \"%s\"\n", 
			} else if (!strcmp(words[0], "reaches				} else if (!strcmp(words[0], "reaches
				handle_reaches(config, lineno |					handle_reaches(lineno, words[
			} else if (!strcmp(words[0], "server"				} else if (!strcmp(words[0], "server"
				handle_server(config, lineno,					handle_server(config, lineno,
			} else if (!strcmp(words[0], "server_				} else if (!strcmp(words[0], "server_
				handle_port(config, lineno, w					handle_port(config, lineno, w
			} else if (!strcmp(words[0], "server_				} else if (!strcmp(words[0], "server_
				handle_type(config, lineno, w					handle_type(config, lineno, w
			} else if (!strcmp(words[0], "default				} else if (!strcmp(words[0], "default
				handle_defuser(config, lineno					handle_defuser(config, lineno
			} else if (!strcmp(words[0], "default				} else if (!strcmp(words[0], "default
				handle_defpass(config, lineno					handle_defpass(config, lineno
			} else if (!strcmp(words[0], "local")				} else if (!strcmp(words[0], "local")
				handle_local(config, lineno, 					handle_local(config, lineno, 
            } else if (!strcmp(words[0], "tordns_enable")) {	            } else if (!strcmp(words[0], "tordns_enable")) {
                handle_tordns_enabled(config, lineno, words[2	                handle_tordns_enabled(config, lineno, words[2
            } else if (!strcmp(words[0], "tordns_deadpool_ran	            } else if (!strcmp(words[0], "tordns_deadpool_ran
                handle_tordns_deadpool_range(config, lineno, 	                handle_tordns_deadpool_range(config, lineno, 
            } else if (!strcmp(words[0], "tordns_cache_size")	            } else if (!strcmp(words[0], "tordns_cache_size")
                handle_tordns_cache_size(config, lineno, word |	                handle_tordns_cache_size(config, words[2]);
            } else {						            } else {
				show_msg(MSGERR, "Invalid pai					show_msg(MSGERR, "Invalid pai
					   "on line %d in con						   "on line %d in con
					   "\"%s\"\n", words[						   "\"%s\"\n", words[
					   savedline);							   savedline);
			}								}
		}								}
	}								}

	return(0);							return(0);
}								}

/* This routines breaks up input lines into tokens  */		/* This routines breaks up input lines into tokens  */
/* and places these tokens into the array specified */		/* and places these tokens into the array specified */
/* by tokens                                        */		/* by tokens                                        */
static int tokenize(char *line, int arrsize, char *tokens[]) 	static int tokenize(char *line, int arrsize, char *tokens[]) 
	int tokenno = -1;						int tokenno = -1;
	int finished = 0;						int finished = 0;

	/* Whitespace is ignored before and after tokens     		/* Whitespace is ignored before and after tokens     
	while ((tokenno < (arrsize - 1)) && 				while ((tokenno < (arrsize - 1)) && 
          (line = line + strspn(line, " \t")) &&		          (line = line + strspn(line, " \t")) &&
	       (*line != (char) 0) && 					       (*line != (char) 0) && 
	       (!finished)) {						       (!finished)) {
		tokenno++;							tokenno++;
		tokens[tokenno] = line;						tokens[tokenno] = line;
		line = line + strcspn(line, " \t");				line = line + strcspn(line, " \t");
		*line = (char) 0;						*line = (char) 0;
		line++;								line++;

		/* We ignore everything after a # */				/* We ignore everything after a # */
		if (*tokens[tokenno] == '#') { 					if (*tokens[tokenno] == '#') { 
			finished = 1;							finished = 1;
			tokenno--;							tokenno--;
		}								}
	}								}

	return(tokenno + 1);						return(tokenno + 1);
}								}

static int handle_path(struct parsedfile *config, int lineno,	static int handle_path(struct parsedfile *config, int lineno,
	struct serverent *newserver;					struct serverent *newserver;

	if ((nowords != 2) || (strcmp(words[1], "{"))) {		if ((nowords != 2) || (strcmp(words[1], "{"))) {
		show_msg(MSGERR, "Badly formed path open stat			show_msg(MSGERR, "Badly formed path open stat
			   "in configuration file (should loo				   "in configuration file (should loo
			   "\"path {\")\n", lineno);					   "\"path {\")\n", lineno);
	} else if (currentcontext != &(config->defaultserver)		} else if (currentcontext != &(config->defaultserver)
		/* You cannot nest path statements so check t			/* You cannot nest path statements so check t
		/* the current context is defaultserver      			/* the current context is defaultserver      
		show_msg(MSGERR, "Path statements cannot be n			show_msg(MSGERR, "Path statements cannot be n
			   "in configuration file\n", lineno)				   "in configuration file\n", lineno)
	} else {							} else {
		/* Open up a new serverent, put it on the lis			/* Open up a new serverent, put it on the lis
		/* then set the current context              			/* then set the current context              
		if (((int) (newserver = (struct serverent *) 			if (((int) (newserver = (struct serverent *) 
			exit(-1);							exit(-1);	
									
		/* Initialize the structure */					/* Initialize the structure */
      show_msg(MSGDEBUG, "New server structure from line %d i	      show_msg(MSGDEBUG, "New server structure from line %d i
               "to 0x%08x\n", lineno, newserver);		               "to 0x%08x\n", lineno, newserver);
      memset(newserver, 0x0, sizeof(*newserver));		      memset(newserver, 0x0, sizeof(*newserver));
		newserver->next = config->paths;				newserver->next = config->paths;
		newserver->lineno = lineno;					newserver->lineno = lineno;
		config->paths = newserver;					config->paths = newserver;
		currentcontext = newserver;					currentcontext = newserver;
	}								}		
 								 
	return(0);							return(0);
}								}

static int handle_endpath(struct parsedfile *config, int line |	static int handle_endpath(struct parsedfile *config, int line

	if (nowords != 1) {						if (nowords != 1) {
		show_msg(MSGERR, "Badly formed path close sta			show_msg(MSGERR, "Badly formed path close sta
			   "%d in configuration file (should 				   "%d in configuration file (should 
			   "\"}\")\n", lineno);						   "\"}\")\n", lineno);
	} else {							} else {
		currentcontext = &(config->defaultserver);			currentcontext = &(config->defaultserver);
	}								}

	/* We could perform some checking on the validty of d		/* We could perform some checking on the validty of d
	/* the completed path here, but thats what verifyconf		/* the completed path here, but thats what verifyconf
	/* designed to do, no point in weighing down libtsock		/* designed to do, no point in weighing down libtsock

	return(0);							return(0);
}								}

static int handle_reaches(struct parsedfile *config, int line |	static int handle_reaches(int lineno, char *value) {
	int rc;								int rc;
	struct netent *ent;						struct netent *ent;

	rc = make_netent(value, &ent);					rc = make_netent(value, &ent);
	switch(rc) {							switch(rc) {
		case 1:								case 1:
			show_msg(MSGERR, "Local network speci				show_msg(MSGERR, "Local network speci
				   "constructed in reach stat					   "constructed in reach stat
				   "%d in configuration "					   "%d in configuration "
				   "file\n", value, lineno);					   "file\n", value, lineno);
			return(0);							return(0);
			break;								break;
		case 2:								case 2:
			show_msg(MSGERR, "IP in reach stateme				show_msg(MSGERR, "IP in reach stateme
				   "network specification (%s					   "network specification (%s
				   "%d in configuration file\					   "%d in configuration file\
			return(0);							return(0);
			break;								break;
		case 3:								case 3:
			show_msg(MSGERR, "SUBNET in reach sta				show_msg(MSGERR, "SUBNET in reach sta
				   "network specification (%s					   "network specification (%s
				   "line %d in configuration 					   "line %d in configuration 
				   lineno);							   lineno);
			return(0);							return(0);
			break;								break;
		case 4:								case 4:
			show_msg(MSGERR, "IP (%s) & ", inet_n				show_msg(MSGERR, "IP (%s) & ", inet_n
			show_msg(MSGERR, "SUBNET (%s) != IP o				show_msg(MSGERR, "SUBNET (%s) != IP o
				   "configuration file, ignor					   "configuration file, ignor
				   inet_ntoa(ent->localnet), 					   inet_ntoa(ent->localnet), 
			return(0);							return(0);
         break;							         break;
		case 5:								case 5:
			show_msg(MSGERR, "Start port in reach				show_msg(MSGERR, "Start port in reach
                    "network specification (%s) is not valid 	                    "network specification (%s) is not valid 
                    "%d in configuration file\n", value, line	                    "%d in configuration file\n", value, line
			return(0);							return(0);
			break;								break;
		case 6:								case 6:
			show_msg(MSGERR, "End port in reach s				show_msg(MSGERR, "End port in reach s
                    "network specification (%s) is not valid 	                    "network specification (%s) is not valid 
                    "%d in configuration file\n", value, line	                    "%d in configuration file\n", value, line
			return(0);							return(0);
			break;								break;
		case 7:								case 7:
			show_msg(MSGERR, "End port in reach s				show_msg(MSGERR, "End port in reach s
                    "network specification (%s) is less than 	                    "network specification (%s) is less than 
                    "port on line %d in configuration file\n"	                    "port on line %d in configuration file\n"
                    lineno);					                    lineno);
			return(0);							return(0);
			break;								break;
	}								}

	/* The entry is valid so add it to linked list */		/* The entry is valid so add it to linked list */
	ent -> next = currentcontext -> reachnets;			ent -> next = currentcontext -> reachnets;
	currentcontext -> reachnets = ent;				currentcontext -> reachnets = ent;

	return(0);							return(0);
}								}

static int handle_server(struct parsedfile *config, int linen	static int handle_server(struct parsedfile *config, int linen
	char *ip;							char *ip;

	ip = strsplit(NULL, &value, " ");				ip = strsplit(NULL, &value, " ");

	/* We don't verify this ip/hostname at this stage, */		/* We don't verify this ip/hostname at this stage, */
	/* its resolved immediately before use in tsocks.c */		/* its resolved immediately before use in tsocks.c */
	if (currentcontext->address == NULL) 				if (currentcontext->address == NULL) 
		currentcontext->address = strdup(ip);				currentcontext->address = strdup(ip);
	else {								else {
		if (currentcontext == &(config->defaultserver			if (currentcontext == &(config->defaultserver
			show_msg(MSGERR, "Only one default SO				show_msg(MSGERR, "Only one default SO
				   "may be specified at line 					   "may be specified at line 
				   "configuration file\n", li					   "configuration file\n", li
		else 								else 
			show_msg(MSGERR, "Only one SOCKS serv				show_msg(MSGERR, "Only one SOCKS serv
				   "per path on line %d in co					   "per path on line %d in co
				   "file. (Path begins on lin					   "file. (Path begins on lin
				   lineno, currentcontext->li					   lineno, currentcontext->li
	}								}

	return(0);							return(0);
}								}

static int handle_port(struct parsedfile *config, int lineno,	static int handle_port(struct parsedfile *config, int lineno,

	if (currentcontext->port != 0) {				if (currentcontext->port != 0) {
		if (currentcontext == &(config->defaultserver			if (currentcontext == &(config->defaultserver
			show_msg(MSGERR, "Server port may onl				show_msg(MSGERR, "Server port may onl
				   "once for default server, 					   "once for default server, 
				   "in configuration file\n",					   "in configuration file\n",
		else 								else 
			show_msg(MSGERR, "Server port may onl				show_msg(MSGERR, "Server port may onl
				   "once per path on line %d 					   "once per path on line %d 
				   "file. (Path begins on lin					   "file. (Path begins on lin
				   lineno, currentcontext->li					   lineno, currentcontext->li
	} else {							} else {
		errno = 0;							errno = 0;
		currentcontext->port = (unsigned short int)			currentcontext->port = (unsigned short int)
				  (strtol(value, (char **)NUL					  (strtol(value, (char **)NUL
		if ((errno != 0) || (currentcontext->port == 			if ((errno != 0) || (currentcontext->port == 
			show_msg(MSGERR, "Invalid server port				show_msg(MSGERR, "Invalid server port
				   "specified in configuratio					   "specified in configuratio
				   "(%s) on line %d\n", value					   "(%s) on line %d\n", value
			currentcontext->port = 0;					currentcontext->port = 0;
		}								}
	}								}
									
	return(0);							return(0);
}								}

static int handle_defuser(struct parsedfile *config, int line	static int handle_defuser(struct parsedfile *config, int line

	if (currentcontext->defuser != NULL) {				if (currentcontext->defuser != NULL) {
		if (currentcontext == &(config->defaultserver			if (currentcontext == &(config->defaultserver
			show_msg(MSGERR, "Default username ma				show_msg(MSGERR, "Default username ma
				   "once for default server, 					   "once for default server, 
				   "in configuration file\n",					   "in configuration file\n",
		else 								else 
			show_msg(MSGERR, "Default username ma				show_msg(MSGERR, "Default username ma
				   "once per path on line %d 					   "once per path on line %d 
				   "file. (Path begins on lin					   "file. (Path begins on lin
				   lineno, currentcontext->li					   lineno, currentcontext->li
	} else {							} else {
		currentcontext->defuser = strdup(value);			currentcontext->defuser = strdup(value);
	}								}
										
	return(0);							return(0);
}								}

static int handle_defpass(struct parsedfile *config, int line	static int handle_defpass(struct parsedfile *config, int line

	if (currentcontext->defpass != NULL) {				if (currentcontext->defpass != NULL) {
		if (currentcontext == &(config->defaultserver			if (currentcontext == &(config->defaultserver
			show_msg(MSGERR, "Default password ma				show_msg(MSGERR, "Default password ma
				   "once for default server, 					   "once for default server, 
				   "in configuration file\n",					   "in configuration file\n",
		else 								else 
			show_msg(MSGERR, "Default password ma				show_msg(MSGERR, "Default password ma
				   "once per path on line %d 					   "once per path on line %d 
				   "file. (Path begins on lin					   "file. (Path begins on lin
				   lineno, currentcontext->li					   lineno, currentcontext->li
	} else {							} else {
		currentcontext->defpass = strdup(value);			currentcontext->defpass = strdup(value);
	}								}
									
	return(0);							return(0);
}								}

static int handle_type(struct parsedfile *config, int lineno,	static int handle_type(struct parsedfile *config, int lineno,

	if (currentcontext->type != 0) {				if (currentcontext->type != 0) {
		if (currentcontext == &(config->defaultserver			if (currentcontext == &(config->defaultserver
			show_msg(MSGERR, "Server type may onl				show_msg(MSGERR, "Server type may onl
				   "once for default server, 					   "once for default server, 
				   "in configuration file\n",					   "in configuration file\n",
		else 								else 
			show_msg(MSGERR, "Server type may onl				show_msg(MSGERR, "Server type may onl
				   "once per path on line %d 					   "once per path on line %d 
				   "file. (Path begins on lin					   "file. (Path begins on lin
				   lineno, currentcontext->li					   lineno, currentcontext->li
	} else {							} else {
		errno = 0;							errno = 0;
		currentcontext->type = (int) strtol(value, (c			currentcontext->type = (int) strtol(value, (c
		if ((errno != 0) || (currentcontext->type == 			if ((errno != 0) || (currentcontext->type == 
		    ((currentcontext->type != 4) && (currentc			    ((currentcontext->type != 4) && (currentc
			show_msg(MSGERR, "Invalid server type				show_msg(MSGERR, "Invalid server type
				   "specified in configuratio					   "specified in configuratio
				   "on line %d, only 4 or 5 m					   "on line %d, only 4 or 5 m
				   "specified\n", value, line					   "specified\n", value, line
			currentcontext->type = 0;					currentcontext->type = 0;
		}								}
	}								}
									
	return(0);							return(0);
}								}

static int handle_flag(char *value) 				static int handle_flag(char *value) 
{								{
    if(!strcasecmp(value, "true") || !strcasecmp(value, "yes"	    if(!strcasecmp(value, "true") || !strcasecmp(value, "yes"
                                  || !strcmp(value, "1")) {	                                  || !strcmp(value, "1")) {
        return 1;						        return 1;
    } else if (!strcasecmp(value, "false") || !strcasecmp(val	    } else if (!strcasecmp(value, "false") || !strcasecmp(val
                                           || !strcmp(value, 	                                           || !strcmp(value, 
        return 0;						        return 0;
    } else {							    } else {
        return -1;						        return -1;
    }    							    }    
}								}

static int handle_tordns_enabled(struct parsedfile *config, i	static int handle_tordns_enabled(struct parsedfile *config, i
                           char *value)				                           char *value)
{								{
    int val = handle_flag(value);				    int val = handle_flag(value);
    if(val == -1) {						    if(val == -1) {
        show_msg(MSGERR, "Invalid value %s supplied for tordn	        show_msg(MSGERR, "Invalid value %s supplied for tordn
                 "line %d in config file, IGNORED\n", value, 	                 "line %d in config file, IGNORED\n", value, 
    } else {							    } else {
        config->tordns_enabled = val;				        config->tordns_enabled = val;
    }								    }
    return 0;							    return 0;
}								}

static int handle_tordns_cache_size(struct parsedfile *config |	static int handle_tordns_cache_size(struct parsedfile *config
                           char *value)				                           char *value)
{								{
    char *endptr;						    char *endptr;
    long size = strtol(value, &endptr, 10);			    long size = strtol(value, &endptr, 10);
    if(*endptr != '\0') {					    if(*endptr != '\0') {
        show_msg(MSGERR, "Error parsing integer value for "	        show_msg(MSGERR, "Error parsing integer value for "
                 "tordns_cache_size (%s), using default %d\n"	                 "tordns_cache_size (%s), using default %d\n"
                 value, config->tordns_cache_size);		                 value, config->tordns_cache_size);
    } else if(size < 128) {					    } else if(size < 128) {
        show_msg(MSGERR, "The value supplied for tordns_cache	        show_msg(MSGERR, "The value supplied for tordns_cache
                 "is too small (<128), using default %d\n", s	                 "is too small (<128), using default %d\n", s
                 config->tordns_cache_size);			                 config->tordns_cache_size);
    } else if(size > 4096) {					    } else if(size > 4096) {
        show_msg(MSGERR, "The value supplied for tordns_cache	        show_msg(MSGERR, "The value supplied for tordns_cache
                 "is too large (>4096), using default %d\n", 	                 "is too large (>4096), using default %d\n", 
                 config->tordns_cache_size);			                 config->tordns_cache_size);
    } else {							    } else {
        config->tordns_cache_size = size;			        config->tordns_cache_size = size;
    }								    }
    return 0;							    return 0;
}								}

static int handle_tordns_deadpool_range(struct parsedfile *co	static int handle_tordns_deadpool_range(struct parsedfile *co
                           char *value)			      |	                           const char *value)
{								{
    int rc;							    int rc;
    struct netent *ent;						    struct netent *ent;

    if (config->tordns_deadpool_range != NULL) {		    if (config->tordns_deadpool_range != NULL) {
        show_msg(MSGERR, "Only one 'deadpool' entry permitted	        show_msg(MSGERR, "Only one 'deadpool' entry permitted
               "second at line %d in configuration file.\n");	               "second at line %d in configuration file.\n");
        return(0);						        return(0);
    }								    }

    if (currentcontext != &(config->defaultserver)) {		    if (currentcontext != &(config->defaultserver)) {
        show_msg(MSGERR, "Deadpool cannot be specified in pat	        show_msg(MSGERR, "Deadpool cannot be specified in pat
               "block at like %d in configuration file. "	               "block at like %d in configuration file. "
               "(Path block started at line %d)\n",		               "(Path block started at line %d)\n",
               lineno, currentcontext->lineno);			               lineno, currentcontext->lineno);
        return(0);						        return(0);
    }								    }

    rc = make_netent(value, &ent);			      |	    rc = make_netent((char *)value, &ent);
    /* This is copied from handle_local and should probably b	    /* This is copied from handle_local and should probably b
       a generic whinge() function or something */		       a generic whinge() function or something */
    switch(rc) {						    switch(rc) {
        case 1:							        case 1:
            show_msg(MSGERR, "The deadpool specification (%s)	            show_msg(MSGERR, "The deadpool specification (%s)
                   "constructed on line %d in configuration "	                   "constructed on line %d in configuration "
                   "file\n", value, lineno);			                   "file\n", value, lineno);
            return(0);						            return(0);
            break;						            break;
        case 2:							        case 2:
            show_msg(MSGERR, "IP for deadpool "			            show_msg(MSGERR, "IP for deadpool "
                   "network specification (%s) is not valid o	                   "network specification (%s) is not valid o
                   "%d in configuration file\n", value, linen	                   "%d in configuration file\n", value, linen
            return(0);						            return(0);
            break;						            break;
        case 3:							        case 3:
            show_msg(MSGERR, "SUBNET for " 			            show_msg(MSGERR, "SUBNET for " 
                   "deadpool network specification (%s) is no	                   "deadpool network specification (%s) is no
                   "line %d in configuration file\n", value, 	                   "line %d in configuration file\n", value, 
                   lineno);					                   lineno);
            return(0);						            return(0);
            break;						            break;
        case 4:							        case 4:
            show_msg(MSGERR, "IP (%s) & ", inet_ntoa(ent->loc	            show_msg(MSGERR, "IP (%s) & ", inet_ntoa(ent->loc
            show_msg(MSGERR, "SUBNET (%s) != IP on line %d in	            show_msg(MSGERR, "SUBNET (%s) != IP on line %d in
                   "configuration file, ignored\n",		                   "configuration file, ignored\n",
                   inet_ntoa(ent->localnet), lineno);		                   inet_ntoa(ent->localnet), lineno);
            return(0);						            return(0);
        case 5:							        case 5:
        case 6:							        case 6:
        case 7:							        case 7:
            show_msg(MSGERR, "Port specification is invalid a	            show_msg(MSGERR, "Port specification is invalid a
                   "not allowed in deadpool specification "	                   "not allowed in deadpool specification "
               "(%s) on line %d in configuration file\n",	               "(%s) on line %d in configuration file\n",
                   value, lineno);				                   value, lineno);
            return(0);						            return(0);
         break;							         break;
    }								    }
    if (ent->startport || ent->endport) {			    if (ent->startport || ent->endport) {
        show_msg(MSGERR, "Port specification is "		        show_msg(MSGERR, "Port specification is "
           "not allowed in deadpool specification "		           "not allowed in deadpool specification "
           "(%s) on line %d in configuration file\n",		           "(%s) on line %d in configuration file\n",
           value, lineno);					           value, lineno);
        return(0);						        return(0);
    }								    }

    config->tordns_deadpool_range = ent;			    config->tordns_deadpool_range = ent;
    return 0;							    return 0;
}								}

static int handle_local(struct parsedfile *config, int lineno |	static int handle_local(struct parsedfile *config, int lineno
	int rc;								int rc;
	struct netent *ent;						struct netent *ent;

	if (currentcontext != &(config->defaultserver)) {		if (currentcontext != &(config->defaultserver)) {
		show_msg(MSGERR, "Local networks cannot be sp			show_msg(MSGERR, "Local networks cannot be sp
			   "block at like %d in configuration				   "block at like %d in configuration
			   "(Path block started at line %d)\n				   "(Path block started at line %d)\n
			   lineno, currentcontext->lineno);				   lineno, currentcontext->lineno);
		return(0);							return(0);
	}								}

	rc = make_netent(value, &ent);			      |		rc = make_netent((char *)value, &ent);
	switch(rc) {							switch(rc) {
		case 1:								case 1:
			show_msg(MSGERR, "Local network speci				show_msg(MSGERR, "Local network speci
				   "constructed on line %d in					   "constructed on line %d in
				   "file\n", value, lineno);					   "file\n", value, lineno);
			return(0);							return(0);
			break;								break;
		case 2:								case 2:
			show_msg(MSGERR, "IP for local "				show_msg(MSGERR, "IP for local "
				   "network specification (%s					   "network specification (%s
				   "%d in configuration file\					   "%d in configuration file\
			return(0);							return(0);
			break;								break;
		case 3:								case 3:
			show_msg(MSGERR, "SUBNET for " 					show_msg(MSGERR, "SUBNET for " 
				   "local network specificati					   "local network specificati
				   "line %d in configuration 					   "line %d in configuration 
				   lineno);							   lineno);
			return(0);							return(0);
			break;								break;
		case 4:								case 4:
			show_msg(MSGERR, "IP (%s) & ", inet_n				show_msg(MSGERR, "IP (%s) & ", inet_n
			show_msg(MSGERR, "SUBNET (%s) != IP o				show_msg(MSGERR, "SUBNET (%s) != IP o
				   "configuration file, ignor					   "configuration file, ignor
				   inet_ntoa(ent->localnet), 					   inet_ntoa(ent->localnet), 
			return(0);							return(0);
		case 5:								case 5:
		case 6:								case 6:
		case 7:								case 7:
			show_msg(MSGERR, "Port specification 				show_msg(MSGERR, "Port specification 
				   "not allowed in local netw					   "not allowed in local netw
               "(%s) on line %d in configuration file\n",	               "(%s) on line %d in configuration file\n",
				   value, lineno);						   value, lineno);
			return(0);							return(0);
         break;							         break;
	}								}

   if (ent->startport || ent->endport) {			   if (ent->startport || ent->endport) {
      show_msg(MSGERR, "Port specification is "			      show_msg(MSGERR, "Port specification is "
            "not allowed in local network specification "	            "not allowed in local network specification "
            "(%s) on line %d in configuration file\n",		            "(%s) on line %d in configuration file\n",
            value, lineno);					            value, lineno);
      return(0);						      return(0);
   }								   }

	/* The entry is valid so add it to linked list */		/* The entry is valid so add it to linked list */
	ent -> next = config->localnets;				ent -> next = config->localnets;
	(config->localnets) = ent;					(config->localnets) = ent;

	return(0);							return(0);
}								}

/* Construct a netent given a string like                    	/* Construct a netent given a string like                    
/* "198.126.0.1[:portno[-portno]]/255.255.255.0"             	/* "198.126.0.1[:portno[-portno]]/255.255.255.0"             
int make_netent(char *value, struct netent **ent) {		int make_netent(char *value, struct netent **ent) {
	char *ip;							char *ip;
	char *subnet;							char *subnet;
   char *startport = NULL;					   char *startport = NULL;
   char *endport = NULL;					   char *endport = NULL;
   char *badchar;						   char *badchar;
   char separator;						   char separator;
	static char buf[200];						static char buf[200];
	char *split;							char *split;

   /* Get a copy of the string so we can modify it */		   /* Get a copy of the string so we can modify it */
	strncpy(buf, value, sizeof(buf) - 1);				strncpy(buf, value, sizeof(buf) - 1);
	buf[sizeof(buf) - 1] = (char) 0;				buf[sizeof(buf) - 1] = (char) 0;
	split = buf;							split = buf;

   /* Now rip it up */						   /* Now rip it up */
	ip = strsplit(&separator, &split, "/:");			ip = strsplit(&separator, &split, "/:");
   if (separator == ':') {					   if (separator == ':') {
      /* We have a start port */				      /* We have a start port */
      startport = strsplit(&separator, &split, "-/");		      startport = strsplit(&separator, &split, "-/");
      if (separator == '-') 					      if (separator == '-') 
         /* We have an end port */				         /* We have an end port */
         endport = strsplit(&separator, &split, "/");		         endport = strsplit(&separator, &split, "/");
   }								   }
	subnet = strsplit(NULL, &split, " \n");				subnet = strsplit(NULL, &split, " \n");

	if ((ip == NULL) || (subnet == NULL)) {				if ((ip == NULL) || (subnet == NULL)) {
		/* Network specification not validly construc			/* Network specification not validly construc
		return(1);							return(1);
   }								   }

   /* Allocate the new entry */					   /* Allocate the new entry */
   if ((*ent = (struct netent *) malloc(sizeof(struct netent)	   if ((*ent = (struct netent *) malloc(sizeof(struct netent)
      == NULL) {						      == NULL) {
      /* If we couldn't malloc some storage, leave */		      /* If we couldn't malloc some storage, leave */
      exit(1);							      exit(1);
   }								   }

   show_msg(MSGDEBUG, "New network entry for %s going to 0x%0	   show_msg(MSGDEBUG, "New network entry for %s going to 0x%0

   if (!startport)						   if (!startport)
      (*ent)->startport = 0;					      (*ent)->startport = 0;
   if (!endport)						   if (!endport)
      (*ent)->endport = 0;					      (*ent)->endport = 0;
         							         
#ifdef HAVE_INET_ADDR						#ifdef HAVE_INET_ADDR
   if (((*ent)->localip.s_addr = inet_addr(ip)) == -1) {	   if (((*ent)->localip.s_addr = inet_addr(ip)) == -1) {
#elif defined(HAVE_INET_ATON)					#elif defined(HAVE_INET_ATON)
   if (!(inet_aton(ip, &((*ent)->localip)))) {			   if (!(inet_aton(ip, &((*ent)->localip)))) {
#endif								#endif
      /* Badly constructed IP */				      /* Badly constructed IP */
      free(*ent);						      free(*ent);
      return(2);						      return(2);
   }								   }
#ifdef HAVE_INET_ADDR						#ifdef HAVE_INET_ADDR
   else if (((*ent)->localnet.s_addr = inet_addr(subnet)) == 	   else if (((*ent)->localnet.s_addr = inet_addr(subnet)) == 
#elif defined(HAVE_INET_ATON)					#elif defined(HAVE_INET_ATON)
   else if (!(inet_aton(subnet, &((*ent)->localnet)))) {	   else if (!(inet_aton(subnet, &((*ent)->localnet)))) {
#endif								#endif
      /* Badly constructed subnet */				      /* Badly constructed subnet */
      free(*ent);						      free(*ent);
      return(3);						      return(3);
   } else if (((*ent)->localip.s_addr &				   } else if (((*ent)->localip.s_addr &
          (*ent)->localnet.s_addr) != 				          (*ent)->localnet.s_addr) != 
                   (*ent)->localip.s_addr) {			                   (*ent)->localip.s_addr) {
      /* Subnet and Ip != Ip */					      /* Subnet and Ip != Ip */
      free(*ent);						      free(*ent);
      return(4);						      return(4);
   } else if (startport && 					   } else if (startport && 
              (!((*ent)->startport = strtol(startport, &badch	              (!((*ent)->startport = strtol(startport, &badch
               (*badchar != 0) || ((*ent)->startport > 65535)	               (*badchar != 0) || ((*ent)->startport > 65535)
      /* Bad start port */					      /* Bad start port */
      free(*ent);						      free(*ent);
      return(5);						      return(5);
   } else if (endport && 					   } else if (endport && 
              (!((*ent)->endport = strtol(endport, &badchar, 	              (!((*ent)->endport = strtol(endport, &badchar, 
               (*badchar != 0) || ((*ent)->endport > 65535)))	               (*badchar != 0) || ((*ent)->endport > 65535)))
      /* Bad end port */					      /* Bad end port */
      free(*ent);						      free(*ent);
      return(6);						      return(6);
   } else if (((*ent)->startport > (*ent)->endport) && !(star	   } else if (((*ent)->startport > (*ent)->endport) && !(star
      /* End port is less than start port */			      /* End port is less than start port */
      free(*ent);						      free(*ent);
      return(7);						      return(7);
   }								   }

   if (startport && !endport)					   if (startport && !endport)
      (*ent)->endport = (*ent)->startport;			      (*ent)->endport = (*ent)->startport;

	return(0);							return(0);
}								}

int is_local(struct parsedfile *config, struct in_addr *testi	int is_local(struct parsedfile *config, struct in_addr *testi
        struct netent *ent;					        struct netent *ent;

	for (ent = (config->localnets); ent != NULL; ent = en		for (ent = (config->localnets); ent != NULL; ent = en
		if ((testip->s_addr & ent->localnet.s_addr) =			if ((testip->s_addr & ent->localnet.s_addr) =
		    (ent->localip.s_addr & ent->localnet.s_ad			    (ent->localip.s_addr & ent->localnet.s_ad
			return(0);							return(0);
		}								}
	}								}

	return(1);							return(1);
}								}

/* Find the appropriate server to reach an ip */		/* Find the appropriate server to reach an ip */
int pick_server(struct parsedfile *config, struct serverent *	int pick_server(struct parsedfile *config, struct serverent *
                struct in_addr *ip, unsigned int port) {	                struct in_addr *ip, unsigned int port) {
	struct netent *net;						struct netent *net;	
   char ipbuf[64];						   char ipbuf[64];

   show_msg(MSGDEBUG, "Picking appropriate server for %s\n", 	   show_msg(MSGDEBUG, "Picking appropriate server for %s\n", 
	*ent = (config->paths);						*ent = (config->paths);
	while (*ent != NULL) {						while (*ent != NULL) {
		/* Go through all the servers looking for one			/* Go through all the servers looking for one
		/* with a path to this network               			/* with a path to this network               
      show_msg(MSGDEBUG, "Checking SOCKS server %s\n", 		      show_msg(MSGDEBUG, "Checking SOCKS server %s\n", 
               ((*ent)->address ? (*ent)->address : "(No Addr	               ((*ent)->address ? (*ent)->address : "(No Addr
		net = (*ent)->reachnets;					net = (*ent)->reachnets;
		while (net != NULL) {						while (net != NULL) {
         strcpy(ipbuf, inet_ntoa(net->localip));		         strcpy(ipbuf, inet_ntoa(net->localip));
         show_msg(MSGDEBUG, "Server can reach %s/%s\n", 	         show_msg(MSGDEBUG, "Server can reach %s/%s\n", 
                  ipbuf, inet_ntoa(net->localnet));		                  ipbuf, inet_ntoa(net->localnet));
			if (((ip->s_addr & net->localnet.s_ad				if (((ip->s_addr & net->localnet.s_ad
              (net->localip.s_addr & net->localnet.s_addr)) &	              (net->localip.s_addr & net->localnet.s_addr)) &
             (!net->startport || 				             (!net->startport || 
              ((net->startport <= port) && (net->endport >= p	              ((net->startport <= port) && (net->endport >= p
         {							         {
            show_msg(MSGDEBUG, "This server can reach target\	            show_msg(MSGDEBUG, "This server can reach target\
				/* Found the net, return */					/* Found the net, return */
				return(0);							return(0);
         }							         }
			net = net->next;						net = net->next;
		}								}		
		(*ent) = (*ent)->next;						(*ent) = (*ent)->next;
	}								}

	*ent = &(config->defaultserver);				*ent = &(config->defaultserver);

	return(0);							return(0);
}								}
									
/* This function is very much like strsep, it looks in a stri	/* This function is very much like strsep, it looks in a stri
/* a character from a list of characters, when it finds one i	/* a character from a list of characters, when it finds one i
/* replaces it with a \0 and returns the start of the string 	/* replaces it with a \0 and returns the start of the string 
/* (basically spitting out tokens with arbitrary separators).	/* (basically spitting out tokens with arbitrary separators).
/* match is found the remainder of the string is returned and	/* match is found the remainder of the string is returned and
/* the start pointer is set to be NULL. The difference betwee	/* the start pointer is set to be NULL. The difference betwee
/* standard strsep and this function is that this one will   	/* standard strsep and this function is that this one will   
/* set *separator to the character separator found if it isn'	/* set *separator to the character separator found if it isn'
char *strsplit(char *separator, char **text, const char *sear	char *strsplit(char *separator, char **text, const char *sear
   int len;						      |	   unsigned int len;
   char *ret;							   char *ret;

   ret = *text;							   ret = *text;

	if (*text == NULL) {						if (*text == NULL) {
      if (separator)						      if (separator)
         *separator = '\0';					         *separator = '\0';
		return(NULL);							return(NULL);
	} else {							} else {
      len = strcspn(*text, search);				      len = strcspn(*text, search);
      if (len == strlen(*text)) {				      if (len == strlen(*text)) {
         if (separator)						         if (separator)
            *separator = '\0';					            *separator = '\0';
         *text = NULL;						         *text = NULL;
      } else {							      } else {
         *text = *text + len;					         *text = *text + len;
         if (separator)						         if (separator)
            *separator = **text;				            *separator = **text;
         **text = '\0';						         **text = '\0';
         *text = *text + 1;					         *text = *text + 1;
      }								      }
	}								}

   return(ret);							   return(ret);
}								}

Only in /home/robert/Development/tork/src/tsocks/: parser.c~
diff -y -x Makefile.am -x Makefile.in -x configure -x INSTALL -x README.TORDNS -x COPYING -x Changelog -x Doxyfile -x FAQ -x TODO ./parser.h /home/robert/Development/tork/src/tsocks/parser.h
/* parser.h - Structures, functions and global variables for 	/* parser.h - Structures, functions and global variables for 
/* tsocks parsing routines                                   	/* tsocks parsing routines                                   

#ifndef _PARSER_H						#ifndef _PARSER_H

#define _PARSER_H	1					#define _PARSER_H	1

/* Structure definitions */					/* Structure definitions */

/* Structure representing one server specified in the config 	/* Structure representing one server specified in the config 
struct serverent {						struct serverent {
	int lineno; /* Line number in conf file this path sta		int lineno; /* Line number in conf file this path sta
	char *address; /* Address/hostname of server */			char *address; /* Address/hostname of server */
	int port; /* Port number of server */				int port; /* Port number of server */
	int type; /* Type of server (4/5) */				int type; /* Type of server (4/5) */
	char *defuser; /* Default username for this socks ser		char *defuser; /* Default username for this socks ser
	char *defpass; /* Default password for this socks ser		char *defpass; /* Default password for this socks ser
	struct netent *reachnets; /* Linked list of nets from		struct netent *reachnets; /* Linked list of nets from
	struct serverent *next; /* Pointer to next server ent		struct serverent *next; /* Pointer to next server ent
};								};

/* Structure representing a network */				/* Structure representing a network */
struct netent {							struct netent {
   struct in_addr localip; /* Base IP of the network */		   struct in_addr localip; /* Base IP of the network */
   struct in_addr localnet; /* Mask for the network */		   struct in_addr localnet; /* Mask for the network */
   unsigned long startport; /* Range of ports for the */	   unsigned long startport; /* Range of ports for the */
   unsigned long endport;   /* network                */	   unsigned long endport;   /* network                */
   struct netent *next; /* Pointer to next network entry */	   struct netent *next; /* Pointer to next network entry */
};								};

/* Structure representing a complete parsed file */		/* Structure representing a complete parsed file */
struct parsedfile {						struct parsedfile {
   struct netent *localnets;					   struct netent *localnets;
   struct serverent defaultserver;				   struct serverent defaultserver;
   struct serverent *paths;					   struct serverent *paths;
   int tordns_enabled;						   int tordns_enabled;
   int tordns_failopen;						   int tordns_failopen;
   int tordns_cache_size;				      |	   unsigned int tordns_cache_size;
   struct netent *tordns_deadpool_range;			   struct netent *tordns_deadpool_range;
};								};

/* Functions provided by parser module */			/* Functions provided by parser module */
int read_config(char *, struct parsedfile *);			int read_config(char *, struct parsedfile *);
int is_local(struct parsedfile *, struct in_addr *);		int is_local(struct parsedfile *, struct in_addr *);
int pick_server(struct parsedfile *, struct serverent **, str	int pick_server(struct parsedfile *, struct serverent **, str
char *strsplit(char *separator, char **text, const char *sear	char *strsplit(char *separator, char **text, const char *sear

#endif								#endif
Only in /home/robert/Development/tork/src/tsocks/: parser.lo
diff -y -x Makefile.am -x Makefile.in -x configure -x INSTALL -x README.TORDNS -x COPYING -x Changelog -x Doxyfile -x FAQ -x TODO ./saveme.c /home/robert/Development/tork/src/tsocks/saveme.c
/* 								/* 

     SAVEME    - Part of the tsocks package			     SAVEME    - Part of the tsocks package
		 This program is designed to be statically li			 This program is designed to be statically li
		 that if a user breaks their ld.so.preload fi			 that if a user breaks their ld.so.preload fi
		 cannot run any dynamically linked program it			 cannot run any dynamically linked program it
		 delete the offending ld.so.preload file.			 delete the offending ld.so.preload file.

    This program is free software; you can redistribute it an	    This program is free software; you can redistribute it an
    it under the terms of the GNU General Public License as p	    it under the terms of the GNU General Public License as p
    the Free Software Foundation; either version 2 of the Lic	    the Free Software Foundation; either version 2 of the Lic
    (at your option) any later version.				    (at your option) any later version.

    This program is distributed in the hope that it will be u	    This program is distributed in the hope that it will be u
    but WITHOUT ANY WARRANTY; without even the implied warran	    but WITHOUT ANY WARRANTY; without even the implied warran
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    GNU General Public License for more details.		    GNU General Public License for more details.

    You should have received a copy of the GNU General Public	    You should have received a copy of the GNU General Public
    along with this program; if not, write to the Free Softwa	    along with this program; if not, write to the Free Softwa
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.	    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

*/								*/

#include <stdio.h>						#include <stdio.h>
#include <unistd.h>						#include <unistd.h>

int main() {							int main() {

	unlink("/etc/ld.so.preload");					unlink("/etc/ld.so.preload");

   return(0);							   return(0);
}								}
Only in /home/robert/Development/tork/src/tsocks/: soname.diff
Only in /home/robert/Development/tork/src/tsocks/: stamp-h2
Only in /home/robert/Development/tork/src/tsocks/: tork-tsocks.conf
Only in /home/robert/Development/tork/src/tsocks/: torkify
Only in /home/robert/Development/tork/src/tsocks/: torkify.1
Only in /home/robert/Development/tork/src/tsocks/: torkify.in
Only in /home/robert/Development/tork/src/tsocks/: torksocks
Only in /home/robert/Development/tork/src/tsocks/: torksocks.1
Only in /home/robert/Development/tork/src/tsocks/: torksocks.8
Only in /home/robert/Development/tork/src/tsocks/: torksocks.announce
Only in /home/robert/Development/tork/src/tsocks/: torksocks.conf.5
Only in .: torksocks.diff
Only in /home/robert/Development/tork/src/tsocks/: torksocks.in
Only in /home/robert/Development/tork/src/tsocks/: torksocks.in~
Only in .: torksockscols.diff
Only in .: tsocks
Only in .: tsocks.1
Only in .: tsocks.8
Only in .: tsocks.announce
diff -y -x Makefile.am -x Makefile.in -x configure -x INSTALL -x README.TORDNS -x COPYING -x Changelog -x Doxyfile -x FAQ -x TODO ./tsocks.c /home/robert/Development/tork/src/tsocks/tsocks.c
/*								/*

    TSOCKS - Wrapper library for transparent SOCKS 		    TSOCKS - Wrapper library for transparent SOCKS 

    Copyright (C) 2000 Shaun Clowes 				    Copyright (C) 2000 Shaun Clowes 

    This program is free software; you can redistribute it an	    This program is free software; you can redistribute it an
    it under the terms of the GNU General Public License as p	    it under the terms of the GNU General Public License as p
    the Free Software Foundation; either version 2 of the Lic	    the Free Software Foundation; either version 2 of the Lic
    (at your option) any later version.				    (at your option) any later version.

    This program is distributed in the hope that it will be u	    This program is distributed in the hope that it will be u
    but WITHOUT ANY WARRANTY; without even the implied warran	    but WITHOUT ANY WARRANTY; without even the implied warran
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    GNU General Public License for more details.		    GNU General Public License for more details.

    You should have received a copy of the GNU General Public	    You should have received a copy of the GNU General Public
    along with this program; if not, write to the Free Softwa	    along with this program; if not, write to the Free Softwa
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.	    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

*/								*/

/* PreProcessor Defines */					/* PreProcessor Defines */
#include <config.h>					      |	#include "../../config.h"

#ifdef USE_GNU_SOURCE						#ifdef USE_GNU_SOURCE
#define _GNU_SOURCE						#define _GNU_SOURCE
#endif								#endif

/* Global configuration variables */				/* Global configuration variables */
char *progname = "libtsocks";         	   /* Name used in er |	const char *progname = "libtsocks";         	   /* Name us

/* Header Files */						/* Header Files */
#include <stdio.h>						#include <stdio.h>
#include <stdlib.h>						#include <stdlib.h>
#include <unistd.h>						#include <unistd.h>
#include <dlfcn.h>						#include <dlfcn.h>
#include <sys/types.h>						#include <sys/types.h>
#include <sys/socket.h>						#include <sys/socket.h>
#include <string.h>						#include <string.h>
#include <strings.h>						#include <strings.h>
							      >	#include <sys/types.h>
#include <netinet/in.h>						#include <netinet/in.h>
#include <arpa/inet.h>						#include <arpa/inet.h>
#include <sys/poll.h>						#include <sys/poll.h>
#include <sys/time.h>						#include <sys/time.h>
#include <pwd.h>						#include <pwd.h>
#include <errno.h>						#include <errno.h>
#include <fcntl.h>						#include <fcntl.h>
#include <common.h>						#include <common.h>
#include <stdarg.h>						#include <stdarg.h>
#ifdef USE_SOCKS_DNS						#ifdef USE_SOCKS_DNS
#include <resolv.h>						#include <resolv.h>
#endif								#endif
#include <parser.h>						#include <parser.h>
#include <tsocks.h>						#include <tsocks.h>
#include "dead_pool.h"						#include "dead_pool.h"

/* Global Declarations */					/* Global Declarations */
#ifdef USE_SOCKS_DNS						#ifdef USE_SOCKS_DNS
static int (*realresinit)(void);				static int (*realresinit)(void);
#endif								#endif
#ifdef USE_TOR_DNS						#ifdef USE_TOR_DNS
static dead_pool *pool = NULL;					static dead_pool *pool = NULL;
static struct hostent *(*realgethostbyname)(GETHOSTBYNAME_SIG	static struct hostent *(*realgethostbyname)(GETHOSTBYNAME_SIG
int (*realgetaddrinfo)(GETADDRINFO_SIGNATURE);			int (*realgetaddrinfo)(GETADDRINFO_SIGNATURE);
static struct hostent *(*realgetipnodebyname)(GETIPNODEBYNAME	static struct hostent *(*realgetipnodebyname)(GETIPNODEBYNAME
#endif								#endif
int (*realconnect)(CONNECT_SIGNATURE);				int (*realconnect)(CONNECT_SIGNATURE);
static int (*realselect)(SELECT_SIGNATURE);			static int (*realselect)(SELECT_SIGNATURE);
static int (*realpoll)(POLL_SIGNATURE);				static int (*realpoll)(POLL_SIGNATURE);
int (*realclose)(CLOSE_SIGNATURE);				int (*realclose)(CLOSE_SIGNATURE);
static int (*realgetpeername)(GETPEERNAME_SIGNATURE);		static int (*realgetpeername)(GETPEERNAME_SIGNATURE);
static struct parsedfile *config;				static struct parsedfile *config;
static struct connreq *requests = NULL;				static struct connreq *requests = NULL;
static int suid = 0;						static int suid = 0;
static char *conffile = NULL;					static char *conffile = NULL;

/* Exported Function Prototypes */				/* Exported Function Prototypes */
void _init(void);					      |	void __attribute__ ((constructor)) tsocks_init(void);
int connect(CONNECT_SIGNATURE);					int connect(CONNECT_SIGNATURE);
int select(SELECT_SIGNATURE);					int select(SELECT_SIGNATURE);
int poll(POLL_SIGNATURE);					int poll(POLL_SIGNATURE);
int close(CLOSE_SIGNATURE);					int close(CLOSE_SIGNATURE);
int getpeername(GETPEERNAME_SIGNATURE);				int getpeername(GETPEERNAME_SIGNATURE);
#ifdef USE_SOCKS_DNS						#ifdef USE_SOCKS_DNS
int res_init(void);						int res_init(void);
#endif								#endif
#ifdef USE_TOR_DNS						#ifdef USE_TOR_DNS
struct hostent *gethostbyname(GETHOSTBYNAME_SIGNATURE);		struct hostent *gethostbyname(GETHOSTBYNAME_SIGNATURE);
int getaddrinfo(GETADDRINFO_SIGNATURE);				int getaddrinfo(GETADDRINFO_SIGNATURE);
struct hostent *getipnodebyname(GETIPNODEBYNAME_SIGNATURE);	struct hostent *getipnodebyname(GETIPNODEBYNAME_SIGNATURE);
#endif 								#endif 

/* Private Function Prototypes */				/* Private Function Prototypes */
static int get_config();					static int get_config();
static int get_environment();					static int get_environment();
static int connect_server(struct connreq *conn);		static int connect_server(struct connreq *conn);
static int send_socks_request(struct connreq *conn);		static int send_socks_request(struct connreq *conn);
static struct connreq *new_socks_request(int sockid, struct s	static struct connreq *new_socks_request(int sockid, struct s
                                         struct sockaddr_in *	                                         struct sockaddr_in *
                                         struct serverent *pa	                                         struct serverent *pa
static void kill_socks_request(struct connreq *conn);		static void kill_socks_request(struct connreq *conn);
static int handle_request(struct connreq *conn);		static int handle_request(struct connreq *conn);
static struct connreq *find_socks_request(int sockid, int inc	static struct connreq *find_socks_request(int sockid, int inc
static int connect_server(struct connreq *conn);		static int connect_server(struct connreq *conn);
static int send_socks_request(struct connreq *conn);		static int send_socks_request(struct connreq *conn);
static int send_socksv4_request(struct connreq *conn);		static int send_socksv4_request(struct connreq *conn);
static int send_socksv5_method(struct connreq *conn);		static int send_socksv5_method(struct connreq *conn);
static int send_socksv5_connect(struct connreq *conn);		static int send_socksv5_connect(struct connreq *conn);
static int send_buffer(struct connreq *conn);			static int send_buffer(struct connreq *conn);
static int recv_buffer(struct connreq *conn);			static int recv_buffer(struct connreq *conn);
static int read_socksv5_method(struct connreq *conn);		static int read_socksv5_method(struct connreq *conn);
static int read_socksv4_req(struct connreq *conn);		static int read_socksv4_req(struct connreq *conn);
static int read_socksv5_connect(struct connreq *conn);		static int read_socksv5_connect(struct connreq *conn);
static int read_socksv5_auth(struct connreq *conn);		static int read_socksv5_auth(struct connreq *conn);
#ifdef USE_TOR_DNS						#ifdef USE_TOR_DNS
static int deadpool_init();				      |	static int deadpool_init(void);
static int send_socksv4a_request(struct connreq *conn, const 	static int send_socksv4a_request(struct connreq *conn, const 
#endif								#endif

void _init(void) {					      |	void tsocks_init(void) {
#ifdef USE_OLD_DLSYM						#ifdef USE_OLD_DLSYM
	void *lib;							void *lib;
#endif								#endif

	/* We could do all our initialization here, but to be		/* We could do all our initialization here, but to be
	/* most programs that are run won't use our services,		/* most programs that are run won't use our services,
	/* we do our general initialization on first call    		/* we do our general initialization on first call    

	/* Determine the logging level */				/* Determine the logging level */
	suid = (getuid() != geteuid());					suid = (getuid() != geteuid());

#ifndef USE_OLD_DLSYM						#ifndef USE_OLD_DLSYM
	realconnect = dlsym(RTLD_NEXT, "connect");			realconnect = dlsym(RTLD_NEXT, "connect");
	realselect = dlsym(RTLD_NEXT, "select");			realselect = dlsym(RTLD_NEXT, "select");
	realpoll = dlsym(RTLD_NEXT, "poll");				realpoll = dlsym(RTLD_NEXT, "poll");
	realclose = dlsym(RTLD_NEXT, "close");				realclose = dlsym(RTLD_NEXT, "close");
	realgetpeername = dlsym(RTLD_NEXT, "getpeername");		realgetpeername = dlsym(RTLD_NEXT, "getpeername");
	#ifdef USE_SOCKS_DNS						#ifdef USE_SOCKS_DNS
	realresinit = dlsym(RTLD_NEXT, "res_init");			realresinit = dlsym(RTLD_NEXT, "res_init");
	#endif								#endif
        #ifdef USE_TOR_DNS				      |	    #ifdef USE_TOR_DNS
	realgethostbyname = dlsym(RTLD_NEXT, "gethostbyname") |	    realgethostbyname = dlsym(RTLD_NEXT, "gethostbyname");
	realgetaddrinfo = dlsym(RTLD_NEXT, "getaddrinfo");    |	    realgetaddrinfo = dlsym(RTLD_NEXT, "getaddrinfo");
	realgetipnodebyname = dlsym(RTLD_NEXT, "getipnodebyna |	    realgetipnodebyname = dlsym(RTLD_NEXT, "getipnodebyname")
        #endif						      |	    #endif
#else								#else
	lib = dlopen(LIBCONNECT, RTLD_LAZY);				lib = dlopen(LIBCONNECT, RTLD_LAZY);
	realconnect = dlsym(lib, "connect");				realconnect = dlsym(lib, "connect");
	realselect = dlsym(lib, "select");				realselect = dlsym(lib, "select");
	realpoll = dlsym(lib, "poll");					realpoll = dlsym(lib, "poll");
	realgetpeername = dlsym(lib, "getpeername");	      <
	#ifdef USE_SOCKS_DNS						#ifdef USE_SOCKS_DNS
	realresinit = dlsym(lib, "res_init");				realresinit = dlsym(lib, "res_init");
	#endif								#endif
	#ifdef USE_TOR_DNS				      |	    #ifdef USE_TOR_DNS
	realgethostbyname = dlsym(lib, "gethostbyname");      |	    realgethostbyname = dlsym(lib, "gethostbyname");
	realgetaddrinfo = dlsym(lib, "getaddrinfo");	      |	    realgetaddrinfo = dlsym(lib, "getaddrinfo");
	realgetipnodebyname = dlsym(RTLD_NEXT, "getipnodebyna |	    realgetipnodebyname = dlsym(RTLD_NEXT, "getipnodebyname")
        #endif						      |	    #endif
	dlclose(lib);					      |	    dlclose(lib);	
	lib = dlopen(LIBC, RTLD_LAZY);					lib = dlopen(LIBC, RTLD_LAZY);
	realclose = dlsym(lib, "close");				realclose = dlsym(lib, "close");
	dlclose(lib);					      |		dlclose(lib);	
#endif								#endif
#ifdef USE_TOR_DNS						#ifdef USE_TOR_DNS
     /* Unfortunately, we can't do this lazily because otherw |	    /* Unfortunately, we can't do this lazily because otherwi
        area won't be shared across fork()s. */		      |	       area won't be shared across fork()s. */
     deadpool_init();					      |	    deadpool_init();
#endif							      |	#endif 
							      <
}								}

static int get_environment() {					static int get_environment() {
   static int done = 0;						   static int done = 0;
							      >	#ifdef ALLOW_MSG_OUTPUT
   int loglevel = MSGERR;					   int loglevel = MSGERR;
   char *logfile = NULL;					   char *logfile = NULL;
   char *env;							   char *env;
							      |	#endif
   if (done)							   if (done)
      return(0);						      return(0);

   /* Determine the logging level */				   /* Determine the logging level */
#ifndef ALLOW_MSG_OUTPUT					#ifndef ALLOW_MSG_OUTPUT
   set_log_options(-1, stderr, 0);			      |	   set_log_options(-1, (char *)stderr, 0);
#else								#else
   if ((env = getenv("TSOCKS_DEBUG")))				   if ((env = getenv("TSOCKS_DEBUG")))
      loglevel = atoi(env);					      loglevel = atoi(env);
   if (((env = getenv("TSOCKS_DEBUG_FILE"))) && !suid)		   if (((env = getenv("TSOCKS_DEBUG_FILE"))) && !suid)
      logfile = env;						      logfile = env;
   set_log_options(loglevel, logfile, 1);			   set_log_options(loglevel, logfile, 1);
#endif								#endif

   done = 1;							   done = 1;

   return(0);							   return(0);
}								}

static int get_config () {					static int get_config () {
   static int done = 0;						   static int done = 0;

   if (done)							   if (done)
      return(0);						      return(0);

   /* Determine the location of the config file */		   /* Determine the location of the config file */
#ifdef ALLOW_ENV_CONFIG						#ifdef ALLOW_ENV_CONFIG
   if (!suid) 							   if (!suid) 
      conffile = getenv("TSOCKS_CONF_FILE");			      conffile = getenv("TSOCKS_CONF_FILE");
#endif								#endif
   								   
	/* Read in the config file */					/* Read in the config file */
   config = malloc(sizeof(*config));				   config = malloc(sizeof(*config));
   if (!config)							   if (!config)
      return(0);						      return(0);
	read_config(conffile, config);			      |	   read_config(conffile, config);
   if (config->paths)						   if (config->paths)
      show_msg(MSGDEBUG, "First lineno for first path is %d\n	      show_msg(MSGDEBUG, "First lineno for first path is %d\n

   done = 1;							   done = 1;

   return(0);							   return(0);
}								}

int connect(CONNECT_SIGNATURE) {				int connect(CONNECT_SIGNATURE) {
	struct sockaddr_in *connaddr;			      |	   struct sockaddr_in *connaddr;
	struct sockaddr_in peer_address;		      |	   struct sockaddr_in peer_address;
	struct sockaddr_in server_address;		      |	   struct sockaddr_in server_address;
   int gotvalidserver = 0, rc, namelen = sizeof(peer_address) |	   int gotvalidserver = 0, rc;
	int sock_type = -1;				      |	   unsigned int namelen = sizeof(peer_address);
	int sock_type_len = sizeof(sock_type);		      |	   int sock_type = -1;
	unsigned int res = -1;				      |	   unsigned int sock_type_len = sizeof(sock_type);
	struct serverent *path;				      |	   int res = -1;
							      >	   struct serverent *path;
   struct connreq *newconn;					   struct connreq *newconn;

   get_environment();						   get_environment();

	/* If the real connect doesn't exist, we're stuffed *		/* If the real connect doesn't exist, we're stuffed *
	if (realconnect == NULL) {					if (realconnect == NULL) {
		show_msg(MSGERR, "Unresolved symbol: connect\			show_msg(MSGERR, "Unresolved symbol: connect\
		return(-1);							return(-1);
	}								}

   show_msg(MSGDEBUG, "Got connection request\n");		   show_msg(MSGDEBUG, "Got connection request\n");

	connaddr = (struct sockaddr_in *) __addr;			connaddr = (struct sockaddr_in *) __addr;

	/* Get the type of the socket */				/* Get the type of the socket */
	getsockopt(__fd, SOL_SOCKET, SO_TYPE, 				getsockopt(__fd, SOL_SOCKET, SO_TYPE, 
		   (void *) &sock_type, &sock_type_len);			   (void *) &sock_type, &sock_type_len);

							      >	    show_msg(MSGDEBUG, "sin_family: %i "
							      >	                        "\n",
							      >	                     connaddr->sin_family);
							      >
							      >	    show_msg(MSGDEBUG, "sockopt: %i "
							      >	                        "\n",
							      >	                     sock_type);
							      >
	/* If this isn't an INET socket for a TCP stream we c		/* If this isn't an INET socket for a TCP stream we c
	/* handle it, just call the real connect now         		/* handle it, just call the real connect now         
   if ((connaddr->sin_family != AF_INET) ||			   if ((connaddr->sin_family != AF_INET) ||
       (sock_type != SOCK_STREAM)) {				       (sock_type != SOCK_STREAM)) {
      show_msg(MSGDEBUG, "Connection isn't a TCP stream ignor	      show_msg(MSGDEBUG, "Connection isn't a TCP stream ignor
		return(realconnect(__fd, __addr, __len));			return(realconnect(__fd, __addr, __len));
   }								   }

   /* If we haven't initialized yet, do it now */		   /* If we haven't initialized yet, do it now */
   get_config();						   get_config();

   /* Are we already handling this connect? */			   /* Are we already handling this connect? */
   if ((newconn = find_socks_request(__fd, 1))) {		   if ((newconn = find_socks_request(__fd, 1))) {
      if (memcmp(&newconn->connaddr, connaddr, sizeof(*connad	      if (memcmp(&newconn->connaddr, connaddr, sizeof(*connad
         /* Ok, they're calling connect on a socket that is i	         /* Ok, they're calling connect on a socket that is i
          * queue but this connect() isn't to the same destin	          * queue but this connect() isn't to the same destin
          * they're obviously not trying to check the status 	          * they're obviously not trying to check the status 
          * they're non blocking connect, they must have clos	          * they're non blocking connect, they must have clos
          * the other socket and created a new one which happ	          * the other socket and created a new one which happ
          * to have the same fd as a request we haven't had t	          * to have the same fd as a request we haven't had t
          * to delete yet, so we delete it here. */		          * to delete yet, so we delete it here. */
         show_msg(MSGDEBUG, "Call to connect received on old 	         show_msg(MSGDEBUG, "Call to connect received on old 
                            "tsocks request for socket %d but	                            "tsocks request for socket %d but
                            "new destination, deleting old re	                            "new destination, deleting old re
                  newconn->sockid);				                  newconn->sockid);
         kill_socks_request(newconn);				         kill_socks_request(newconn);
      } else {							      } else {
         /* Ok, this call to connect() is to check the status	         /* Ok, this call to connect() is to check the status
          * a current non blocking connect(). */		          * a current non blocking connect(). */
         if (newconn->state == FAILED) {			         if (newconn->state == FAILED) {
            show_msg(MSGDEBUG, "Call to connect received on f	            show_msg(MSGDEBUG, "Call to connect received on f
                               "request %d, returning %d\n",	                               "request %d, returning %d\n",
                     newconn->sockid, newconn->err);		                     newconn->sockid, newconn->err);
            errno = newconn->err;				            errno = newconn->err;
            rc = -1;						            rc = -1;
         } else if (newconn->state == DONE) {			         } else if (newconn->state == DONE) {
            show_msg(MSGERR, "Call to connect received on com	            show_msg(MSGERR, "Call to connect received on com
                             "request %d\n",			                             "request %d\n",
                     newconn->sockid, newconn->err);		                     newconn->sockid, newconn->err);
            rc = 0;						            rc = 0;
         } else {						         } else {
            show_msg(MSGDEBUG, "Call to connect received on c	            show_msg(MSGDEBUG, "Call to connect received on c
                     newconn->sockid);				                     newconn->sockid);
            rc = handle_request(newconn);			            rc = handle_request(newconn);
            errno = rc;						            errno = rc;
         }							         }
         if ((newconn->state == FAILED) || (newconn->state ==	         if ((newconn->state == FAILED) || (newconn->state ==
            kill_socks_request(newconn);			            kill_socks_request(newconn);
         return((rc ? -1 : 0));					         return((rc ? -1 : 0));
      }								      }
   }								   }

   /* If the socket is already connected, just call connect  	   /* If the socket is already connected, just call connect  
   /* and get its standard reply                             	   /* and get its standard reply                             
   if (!getpeername(__fd, (struct sockaddr *) &peer_address, 	   if (!getpeername(__fd, (struct sockaddr *) &peer_address, 
      show_msg(MSGDEBUG, "Socket is already connected, deferi	      show_msg(MSGDEBUG, "Socket is already connected, deferi
                         "real connect\n");			                         "real connect\n");
		return(realconnect(__fd, __addr, __len));			return(realconnect(__fd, __addr, __len));
   }								   }
     								     
   show_msg(MSGDEBUG, "Got connection request for socket %d t	   show_msg(MSGDEBUG, "Got connection request for socket %d t
                      "%s\n", __fd, inet_ntoa(connaddr->sin_a	                      "%s\n", __fd, inet_ntoa(connaddr->sin_a

   /* If the address is local call realconnect */		   /* If the address is local call realconnect */
#ifdef USE_TOR_DNS						#ifdef USE_TOR_DNS
   if (!(is_local(config, &(connaddr->sin_addr))) && 		   if (!(is_local(config, &(connaddr->sin_addr))) && 
       !is_dead_address(pool, connaddr->sin_addr.s_addr)) {	       !is_dead_address(pool, connaddr->sin_addr.s_addr)) {
#else 								#else 
   if (!(is_local(config, &(connaddr->sin_addr)))) {		   if (!(is_local(config, &(connaddr->sin_addr)))) {
#endif								#endif
      show_msg(MSGDEBUG, "Connection for socket %d is local\n	      show_msg(MSGDEBUG, "Connection for socket %d is local\n
      return(realconnect(__fd, __addr, __len));			      return(realconnect(__fd, __addr, __len));
   }								   }

   /* Ok, so its not local, we need a path to the net */	   /* Ok, so its not local, we need a path to the net */
   pick_server(config, &path, &(connaddr->sin_addr), ntohs(co	   pick_server(config, &path, &(connaddr->sin_addr), ntohs(co

   show_msg(MSGDEBUG, "Picked server %s for connection\n",	   show_msg(MSGDEBUG, "Picked server %s for connection\n",
            (path->address ? path->address : "(Not Provided)"	            (path->address ? path->address : "(Not Provided)"
   if (path->address == NULL) {					   if (path->address == NULL) {
      if (path == &(config->defaultserver)) 			      if (path == &(config->defaultserver)) 
         show_msg(MSGERR, "Connection needs to be made "	         show_msg(MSGERR, "Connection needs to be made "
                          "via default server but "		                          "via default server but "
                          "the default server has not "		                          "the default server has not "
                          "been specified\n");			                          "been specified\n");
      else 							      else 
         show_msg(MSGERR, "Connection needs to be made "	         show_msg(MSGERR, "Connection needs to be made "
                          "via path specified at line "		                          "via path specified at line "
                          "%d in configuration file but "	                          "%d in configuration file but "
                          "the server has not been "		                          "the server has not been "
                          "specified for this path\n",		                          "specified for this path\n",
                  path->lineno);				                  path->lineno);
   } else if ((res = resolve_ip(path->address, 0, HOSTNAMES))	   } else if ((res = resolve_ip(path->address, 0, HOSTNAMES))
      show_msg(MSGERR, "The SOCKS server (%s) listed in the c	      show_msg(MSGERR, "The SOCKS server (%s) listed in the c
                       "file which needs to be used for this 	                       "file which needs to be used for this 
                       "is invalid\n", path->address);		                       "is invalid\n", path->address);
   } else {							   } else {	
      /* Construct the addr for the socks server */		      /* Construct the addr for the socks server */
      server_address.sin_family = AF_INET; /* host byte order	      server_address.sin_family = AF_INET; /* host byte order
      server_address.sin_addr.s_addr = res;			      server_address.sin_addr.s_addr = res;
      server_address.sin_port = htons(path->port);		      server_address.sin_port = htons(path->port);
      bzero(&(server_address.sin_zero), 8);			      bzero(&(server_address.sin_zero), 8);

      /* Complain if this server isn't on a localnet */		      /* Complain if this server isn't on a localnet */
      if (is_local(config, &server_address.sin_addr)) {		      if (is_local(config, &server_address.sin_addr)) {
         show_msg(MSGERR, "SOCKS server %s (%s) is not on a l	         show_msg(MSGERR, "SOCKS server %s (%s) is not on a l
                  path->address, inet_ntoa(server_address.sin	                  path->address, inet_ntoa(server_address.sin
      } else 							      } else 
         gotvalidserver = 1;					         gotvalidserver = 1;
   }								   }

   /* If we haven't found a valid server we return connection	   /* If we haven't found a valid server we return connection
   if (!gotvalidserver || 					   if (!gotvalidserver || 
       !(newconn = new_socks_request(__fd, connaddr, &server_	       !(newconn = new_socks_request(__fd, connaddr, &server_
      errno = ECONNREFUSED;					      errno = ECONNREFUSED;
      return(-1);						      return(-1);
   } else {							   } else {
      /* Now we call the main function to handle the connect.	      /* Now we call the main function to handle the connect.
      rc = handle_request(newconn);				      rc = handle_request(newconn);
      /* If the request completed immediately it mustn't have	      /* If the request completed immediately it mustn't have
       * a non blocking socket, in this case we don't need to	       * a non blocking socket, in this case we don't need to
       * about this socket anymore. */				       * about this socket anymore. */
      if ((newconn->state == FAILED) || (newconn->state == DO	      if ((newconn->state == FAILED) || (newconn->state == DO
         kill_socks_request(newconn);				         kill_socks_request(newconn);
      errno = rc;						      errno = rc;
      return((rc ? -1 : 0));					      return((rc ? -1 : 0));
   }								   }
}								}

int select(SELECT_SIGNATURE) {					int select(SELECT_SIGNATURE) {
   int nevents = 0;						   int nevents = 0;
   int rc = 0;							   int rc = 0;
   int setevents = 0;						   int setevents = 0;
   int monitoring = 0;						   int monitoring = 0;
   struct connreq *conn, *nextconn;				   struct connreq *conn, *nextconn;
   fd_set mywritefds, myreadfds, myexceptfds;			   fd_set mywritefds, myreadfds, myexceptfds;

   /* If we're not currently managing any requests we can jus	   /* If we're not currently managing any requests we can jus
    * leave here */						    * leave here */
   if (!requests) {						   if (!requests) {
      show_msg(MSGDEBUG, "No requests waiting, calling real s	      show_msg(MSGDEBUG, "No requests waiting, calling real s
      return(realselect(n, readfds, writefds, exceptfds, time	      return(realselect(n, readfds, writefds, exceptfds, time
   }								   }

   get_environment();						   get_environment();

   show_msg(MSGDEBUG, "Intercepted call to select with %d fds	   show_msg(MSGDEBUG, "Intercepted call to select with %d fds
            "0x%08x 0x%08x 0x%08x, timeout %08x\n", n, 		            "0x%08x 0x%08x 0x%08x, timeout %08x\n", n, 
            readfds, writefds, exceptfds, timeout);		            readfds, writefds, exceptfds, timeout);

   for (conn = requests; conn != NULL; conn = conn->next) {	   for (conn = requests; conn != NULL; conn = conn->next) {
      if ((conn->state == FAILED) || (conn->state == DONE))	      if ((conn->state == FAILED) || (conn->state == DONE))
         continue;						         continue;
      conn->selectevents = 0;					      conn->selectevents = 0;
      show_msg(MSGDEBUG, "Checking requests for socks enabled	      show_msg(MSGDEBUG, "Checking requests for socks enabled
               conn->sockid);					               conn->sockid);
      conn->selectevents |= (writefds ? (FD_ISSET(conn->socki	      conn->selectevents |= (writefds ? (FD_ISSET(conn->socki
      conn->selectevents |= (readfds ? (FD_ISSET(conn->sockid	      conn->selectevents |= (readfds ? (FD_ISSET(conn->sockid
      conn->selectevents |= (exceptfds ? (FD_ISSET(conn->sock	      conn->selectevents |= (exceptfds ? (FD_ISSET(conn->sock
      if (conn->selectevents) {					      if (conn->selectevents) {
         show_msg(MSGDEBUG, "Socket %d was set for events\n",	         show_msg(MSGDEBUG, "Socket %d was set for events\n",
         monitoring = 1;					         monitoring = 1;
      }								      }
   }								   }

   if (!monitoring)						   if (!monitoring)
      return(realselect(n, readfds, writefds, exceptfds, time	      return(realselect(n, readfds, writefds, exceptfds, time

   /* This is our select loop. In it we repeatedly call selec	   /* This is our select loop. In it we repeatedly call selec
    * pass select the same fdsets as provided by the caller e	    * pass select the same fdsets as provided by the caller e
    * modify the fdsets for the sockets we're managing to get	    * modify the fdsets for the sockets we're managing to get
    * we're interested in (while negotiating with the socks s	    * we're interested in (while negotiating with the socks s
    * events we're interested in happen we go off and process	    * events we're interested in happen we go off and process
    * ourselves, without returning the events to the caller. 	    * ourselves, without returning the events to the caller. 
    * ends when an event which isn't one we need to handle oc	    * ends when an event which isn't one we need to handle oc
    * the select times out */					    * the select times out */
   do {								   do {
      /* Copy the clients fd events, we'll change them as we 	      /* Copy the clients fd events, we'll change them as we 
      if (readfds)						      if (readfds)
         memcpy(&myreadfds, readfds, sizeof(myreadfds));	         memcpy(&myreadfds, readfds, sizeof(myreadfds));
      else							      else
         FD_ZERO(&myreadfds);					         FD_ZERO(&myreadfds);
      if (writefds)						      if (writefds)
         memcpy(&mywritefds, writefds, sizeof(mywritefds));	         memcpy(&mywritefds, writefds, sizeof(mywritefds));
      else							      else
         FD_ZERO(&mywritefds);					         FD_ZERO(&mywritefds);
      if (exceptfds)						      if (exceptfds)
         memcpy(&myexceptfds, exceptfds, sizeof(myexceptfds))	         memcpy(&myexceptfds, exceptfds, sizeof(myexceptfds))
      else							      else
         FD_ZERO(&myexceptfds);					         FD_ZERO(&myexceptfds);

      /* Now enable our sockets for the events WE want to hea	      /* Now enable our sockets for the events WE want to hea
      for (conn = requests; conn != NULL; conn = conn->next) 	      for (conn = requests; conn != NULL; conn = conn->next) 
         if ((conn->state == FAILED) || (conn->state == DONE)	         if ((conn->state == FAILED) || (conn->state == DONE)
             (conn->selectevents == 0))				             (conn->selectevents == 0))
            continue;						            continue;
         /* We always want to know about socket exceptions */	         /* We always want to know about socket exceptions */
         FD_SET(conn->sockid, &myexceptfds);			         FD_SET(conn->sockid, &myexceptfds);
         /* If we're waiting for a connect or to be able to s	         /* If we're waiting for a connect or to be able to s
          * on a socket we want to get write events */		          * on a socket we want to get write events */
         if ((conn->state == SENDING) || (conn->state == CONN	         if ((conn->state == SENDING) || (conn->state == CONN
            FD_SET(conn->sockid,&mywritefds);			            FD_SET(conn->sockid,&mywritefds);
         else							         else
            FD_CLR(conn->sockid,&mywritefds);			            FD_CLR(conn->sockid,&mywritefds);
         /* If we're waiting to receive data we want to get 	         /* If we're waiting to receive data we want to get 
          * read events */					          * read events */
         if (conn->state == RECEIVING)				         if (conn->state == RECEIVING)
            FD_SET(conn->sockid,&myreadfds);			            FD_SET(conn->sockid,&myreadfds);
         else							         else
            FD_CLR(conn->sockid,&myreadfds);			            FD_CLR(conn->sockid,&myreadfds);
      }								      }

      nevents = realselect(n, &myreadfds, &mywritefds, &myexc	      nevents = realselect(n, &myreadfds, &mywritefds, &myexc
      /* If there were no events we must have timed out or ha	      /* If there were no events we must have timed out or ha
      if (nevents <= 0)						      if (nevents <= 0)
         break;							         break;

      /* Loop through all the sockets we're monitoring and se	      /* Loop through all the sockets we're monitoring and se
       * any of them have had events */				       * any of them have had events */
      for (conn = requests; conn != NULL; conn = nextconn) {	      for (conn = requests; conn != NULL; conn = nextconn) {
         nextconn = conn->next;					         nextconn = conn->next;
         if ((conn->state == FAILED) || (conn->state == DONE)	         if ((conn->state == FAILED) || (conn->state == DONE)
            continue;						            continue;
         show_msg(MSGDEBUG, "Checking socket %d for events\n"	         show_msg(MSGDEBUG, "Checking socket %d for events\n"
         /* Clear all the events on the socket (if any), we'l	         /* Clear all the events on the socket (if any), we'l
          * any that are necessary later. */			          * any that are necessary later. */
         setevents = 0;						         setevents = 0;
         if (FD_ISSET(conn->sockid, &mywritefds))  {		         if (FD_ISSET(conn->sockid, &mywritefds))  {
            nevents--;						            nevents--;
            setevents |= WRITE;					            setevents |= WRITE;
            show_msg(MSGDEBUG, "Socket had write event\n");	            show_msg(MSGDEBUG, "Socket had write event\n");
            FD_CLR(conn->sockid, &mywritefds);			            FD_CLR(conn->sockid, &mywritefds);
         }							         }
         if (FD_ISSET(conn->sockid, &myreadfds))  {		         if (FD_ISSET(conn->sockid, &myreadfds))  {
            nevents--;						            nevents--;
            setevents |= READ;					            setevents |= READ;
            show_msg(MSGDEBUG, "Socket had write event\n");	            show_msg(MSGDEBUG, "Socket had write event\n");
            FD_CLR(conn->sockid, &myreadfds);			            FD_CLR(conn->sockid, &myreadfds);
         }							         }
         if (FD_ISSET(conn->sockid, &myexceptfds))  {		         if (FD_ISSET(conn->sockid, &myexceptfds))  {
            nevents--;						            nevents--;
            setevents |= EXCEPT;				            setevents |= EXCEPT;
            show_msg(MSGDEBUG, "Socket had except event\n");	            show_msg(MSGDEBUG, "Socket had except event\n");
            FD_CLR(conn->sockid, &myexceptfds);			            FD_CLR(conn->sockid, &myexceptfds);
         }							         }

         if (!setevents) {					         if (!setevents) {
            show_msg(MSGDEBUG, "No events on socket %d\n", co	            show_msg(MSGDEBUG, "No events on socket %d\n", co
            continue;						            continue;
         }							         }

         if (setevents & EXCEPT) {				         if (setevents & EXCEPT) {
            conn->state = FAILED;				            conn->state = FAILED;
         } else {						         } else {
            rc = handle_request(conn);				            rc = handle_request(conn);
         }							         }
         /* If the connection hasn't failed or completed ther	         /* If the connection hasn't failed or completed ther
          * to report to the client */				          * to report to the client */
         if ((conn->state != FAILED) && 			         if ((conn->state != FAILED) && 
             (conn->state != DONE))  				             (conn->state != DONE))  
            continue;						            continue;

         /* Ok, the connection is completed, for good or for 	         /* Ok, the connection is completed, for good or for 
          * hand back the relevant events to the caller. We d	          * hand back the relevant events to the caller. We d
          * connection though since the caller should call co	          * connection though since the caller should call co
          * check the status, we delete it then */		          * check the status, we delete it then */

         if (conn->state == FAILED) {				         if (conn->state == FAILED) {
            /* Damn, the connection failed. Whatever the even	            /* Damn, the connection failed. Whatever the even
             * was selected for we flag */			             * was selected for we flag */
            if (conn->selectevents & EXCEPT) {			            if (conn->selectevents & EXCEPT) {
               FD_SET(conn->sockid, &myexceptfds);		               FD_SET(conn->sockid, &myexceptfds);
               nevents++;					               nevents++;
            }							            }
            if (conn->selectevents & READ) {			            if (conn->selectevents & READ) {
               FD_SET(conn->sockid, &myreadfds);		               FD_SET(conn->sockid, &myreadfds);
               nevents++;					               nevents++;
            }							            }
            if (conn->selectevents & WRITE) {			            if (conn->selectevents & WRITE) {
               FD_SET(conn->sockid, &mywritefds);		               FD_SET(conn->sockid, &mywritefds);
               nevents++;					               nevents++;
            }							            }
            /* We should use setsockopt to set the SO_ERROR e	            /* We should use setsockopt to set the SO_ERROR e
             * socket, but this isn't allowed for some silly 	             * socket, but this isn't allowed for some silly 
             * leaves us a bit hamstrung.			             * leaves us a bit hamstrung.
             * We don't delete the request so that hopefully 	             * We don't delete the request so that hopefully 
             * return the error on the socket if they call co	             * return the error on the socket if they call co
         } else {						         } else {
            /* The connection is done,  if the client selecte	            /* The connection is done,  if the client selecte
             * writing we can go ahead and signal that now (s	             * writing we can go ahead and signal that now (s
             * be ready for writing), otherwise we'll just le	             * be ready for writing), otherwise we'll just le
             * come around again (since we can't flag it for 	             * come around again (since we can't flag it for 
             * if there is any data to be read and can't be b	             * if there is any data to be read and can't be b
            if (conn->selectevents & WRITE) {			            if (conn->selectevents & WRITE) {
               FD_SET(conn->sockid, &mywritefds);		               FD_SET(conn->sockid, &mywritefds);
               nevents++;					               nevents++;
            }							            }
         }							         }
      }								      }
   } while (nevents == 0);					   } while (nevents == 0);

   show_msg(MSGDEBUG, "Finished intercepting select(), %d eve	   show_msg(MSGDEBUG, "Finished intercepting select(), %d eve

   /* Now copy our event blocks back to the client blocks */	   /* Now copy our event blocks back to the client blocks */
   if (readfds)							   if (readfds)
      memcpy(readfds, &myreadfds, sizeof(myreadfds));		      memcpy(readfds, &myreadfds, sizeof(myreadfds));
   if (writefds)						   if (writefds)
      memcpy(writefds, &mywritefds, sizeof(mywritefds));	      memcpy(writefds, &mywritefds, sizeof(mywritefds));
   if (exceptfds)						   if (exceptfds)
      memcpy(exceptfds, &myexceptfds, sizeof(myexceptfds));	      memcpy(exceptfds, &myexceptfds, sizeof(myexceptfds));

   return(nevents);						   return(nevents);
}								}

int poll(POLL_SIGNATURE) {					int poll(POLL_SIGNATURE) {
   int nevents = 0;						   int nevents = 0;
   int rc = 0, i;					      |	   int rc = 0;
							      >	   unsigned int i;
   int setevents = 0;						   int setevents = 0;
   int monitoring = 0;						   int monitoring = 0;
   struct connreq *conn, *nextconn;				   struct connreq *conn, *nextconn;

   /* If we're not currently managing any requests we can jus	   /* If we're not currently managing any requests we can jus
    * leave here */						    * leave here */
   if (!requests)						   if (!requests)
      return(realpoll(ufds, nfds, timeout));			      return(realpoll(ufds, nfds, timeout));

   get_environment();						   get_environment();

   show_msg(MSGDEBUG, "Intercepted call to poll with %d fds, 	   show_msg(MSGDEBUG, "Intercepted call to poll with %d fds, 
            "0x%08x timeout %d\n", nfds, ufds, timeout);	            "0x%08x timeout %d\n", nfds, ufds, timeout);

   for (conn = requests; conn != NULL; conn = conn->next)	   for (conn = requests; conn != NULL; conn = conn->next)
      conn->selectevents = 0;					      conn->selectevents = 0;

   /* Record what events on our sockets the caller was intere	   /* Record what events on our sockets the caller was intere
    * in */							    * in */
   for (i = 0; i < nfds; i++) {					   for (i = 0; i < nfds; i++) {
      if (!(conn = find_socks_request(ufds[i].fd, 0)))		      if (!(conn = find_socks_request(ufds[i].fd, 0)))
         continue;						         continue;
      show_msg(MSGDEBUG, "Have event checks for socks enabled	      show_msg(MSGDEBUG, "Have event checks for socks enabled
               conn->sockid);					               conn->sockid);
      conn->selectevents = ufds[i].events;			      conn->selectevents = ufds[i].events;
      monitoring = 1;						      monitoring = 1;
   }								   }

   if (!monitoring)						   if (!monitoring)
      return(realpoll(ufds, nfds, timeout));			      return(realpoll(ufds, nfds, timeout));

   /* This is our poll loop. In it we repeatedly call poll().	   /* This is our poll loop. In it we repeatedly call poll().
    * pass select the same event list as provided by the call	    * pass select the same event list as provided by the call
    * modify the events for the sockets we're managing to get	    * modify the events for the sockets we're managing to get
    * we're interested in (while negotiating with the socks s	    * we're interested in (while negotiating with the socks s
    * events we're interested in happen we go off and process	    * events we're interested in happen we go off and process
    * ourselves, without returning the events to the caller. 	    * ourselves, without returning the events to the caller. 
    * ends when an event which isn't one we need to handle oc	    * ends when an event which isn't one we need to handle oc
    * the poll times out */					    * the poll times out */
   do {								   do {
      /* Enable our sockets for the events WE want to hear ab	      /* Enable our sockets for the events WE want to hear ab
      for (i = 0; i < nfds; i++) {				      for (i = 0; i < nfds; i++) {
         if (!(conn = find_socks_request(ufds[i].fd, 0)))	         if (!(conn = find_socks_request(ufds[i].fd, 0)))
            continue;						            continue;

         /* We always want to know about socket exceptions bu	         /* We always want to know about socket exceptions bu
          * always returned (i.e they don't need to be in the	          * always returned (i.e they don't need to be in the
          * wanted events to be returned by the kernel */	          * wanted events to be returned by the kernel */
         ufds[i].events = 0;					         ufds[i].events = 0;

         /* If we're waiting for a connect or to be able to s	         /* If we're waiting for a connect or to be able to s
          * on a socket we want to get write events */		          * on a socket we want to get write events */
         if ((conn->state == SENDING) || (conn->state == CONN	         if ((conn->state == SENDING) || (conn->state == CONN
            ufds[i].events |= POLLOUT;				            ufds[i].events |= POLLOUT;
         /* If we're waiting to receive data we want to get 	         /* If we're waiting to receive data we want to get 
          * read events */					          * read events */
         if (conn->state == RECEIVING)				         if (conn->state == RECEIVING)
            ufds[i].events |= POLLIN;				            ufds[i].events |= POLLIN;
      }								      }

      nevents = realpoll(ufds, nfds, timeout);			      nevents = realpoll(ufds, nfds, timeout);
      /* If there were no events we must have timed out or ha	      /* If there were no events we must have timed out or ha
      if (nevents <= 0)						      if (nevents <= 0)
         break;							         break;

      /* Loop through all the sockets we're monitoring and se	      /* Loop through all the sockets we're monitoring and se
       * any of them have had events */				       * any of them have had events */
      for (conn = requests; conn != NULL; conn = nextconn) {	      for (conn = requests; conn != NULL; conn = nextconn) {
         nextconn = conn->next;					         nextconn = conn->next;
         if ((conn->state == FAILED) || (conn->state == DONE)	         if ((conn->state == FAILED) || (conn->state == DONE)
            continue;						            continue;

         /* Find the socket in the poll list */			         /* Find the socket in the poll list */
         for (i = 0; ((i < nfds) && (ufds[i].fd != conn->sock	         for (i = 0; ((i < nfds) && (ufds[i].fd != conn->sock
            /* Empty Loop */;					            /* Empty Loop */;
         if (i == nfds) 					         if (i == nfds) 
            continue;						            continue;

         show_msg(MSGDEBUG, "Checking socket %d for events\n"	         show_msg(MSGDEBUG, "Checking socket %d for events\n"

         if (!ufds[i].revents) {				         if (!ufds[i].revents) {
            show_msg(MSGDEBUG, "No events on socket\n");	            show_msg(MSGDEBUG, "No events on socket\n");
            continue;						            continue;
         }							         }

         /* Clear any read or write events on the socket, we'	         /* Clear any read or write events on the socket, we'
          * any that are necessary later. */			          * any that are necessary later. */
         setevents = ufds[i].revents;				         setevents = ufds[i].revents;
         if (setevents & POLLIN) {				         if (setevents & POLLIN) {
            show_msg(MSGDEBUG, "Socket had read event\n");	            show_msg(MSGDEBUG, "Socket had read event\n");
            ufds[i].revents &= ~POLLIN;				            ufds[i].revents &= ~POLLIN;
            nevents--;						            nevents--;
         }							         }
         if (setevents & POLLOUT) {				         if (setevents & POLLOUT) {
            show_msg(MSGDEBUG, "Socket had write event\n");	            show_msg(MSGDEBUG, "Socket had write event\n");
            ufds[i].revents &= ~POLLOUT;			            ufds[i].revents &= ~POLLOUT;
            nevents--;						            nevents--;
         }							         }
         if (setevents & (POLLERR | POLLNVAL | POLLHUP)) 	         if (setevents & (POLLERR | POLLNVAL | POLLHUP)) 
            show_msg(MSGDEBUG, "Socket had error event\n");	            show_msg(MSGDEBUG, "Socket had error event\n");

         /* Now handle this event */				         /* Now handle this event */
         if (setevents & (POLLERR | POLLNVAL | POLLHUP)) {	         if (setevents & (POLLERR | POLLNVAL | POLLHUP)) {
            conn->state = FAILED;				            conn->state = FAILED;
         } else {						         } else {
            rc = handle_request(conn);				            rc = handle_request(conn);
         }							         }
         /* If the connection hasn't failed or completed ther	         /* If the connection hasn't failed or completed ther
          * to report to the client */				          * to report to the client */
         if ((conn->state != FAILED) && 			         if ((conn->state != FAILED) && 
             (conn->state != DONE))  				             (conn->state != DONE))  
            continue;						            continue;

         /* Ok, the connection is completed, for good or for 	         /* Ok, the connection is completed, for good or for 
          * hand back the relevant events to the caller. We d	          * hand back the relevant events to the caller. We d
          * connection though since the caller should call co	          * connection though since the caller should call co
          * check the status, we delete it then */		          * check the status, we delete it then */

         if (conn->state == FAILED) {				         if (conn->state == FAILED) {
            /* Damn, the connection failed. Just copy back th	            /* Damn, the connection failed. Just copy back th
             * from the poll call, error events are always va	             * from the poll call, error events are always va
             * requested by the client */			             * requested by the client */
            /* We should use setsockopt to set the SO_ERROR e	            /* We should use setsockopt to set the SO_ERROR e
             * socket, but this isn't allowed for some silly 	             * socket, but this isn't allowed for some silly 
             * leaves us a bit hamstrung.			             * leaves us a bit hamstrung.
             * We don't delete the request so that hopefully 	             * We don't delete the request so that hopefully 
             * return the error on the socket if they call co	             * return the error on the socket if they call co
         } else {						         } else {
            /* The connection is done,  if the client polled 	            /* The connection is done,  if the client polled 
             * writing we can go ahead and signal that now (s	             * writing we can go ahead and signal that now (s
             * be ready for writing), otherwise we'll just le	             * be ready for writing), otherwise we'll just le
             * come around again (since we can't flag it for 	             * come around again (since we can't flag it for 
             * if there is any data to be read and can't be b	             * if there is any data to be read and can't be b
            if (conn->selectevents & WRITE) {			            if (conn->selectevents & WRITE) {
               setevents |= POLLOUT; 				               setevents |= POLLOUT; 
               nevents++;					               nevents++;
            }							            }
         }							         }
      }								      }
   } while (nevents == 0);					   } while (nevents == 0);

   show_msg(MSGDEBUG, "Finished intercepting poll(), %d event	   show_msg(MSGDEBUG, "Finished intercepting poll(), %d event

   /* Now restore the events polled in each of the blocks */	   /* Now restore the events polled in each of the blocks */
   for (i = 0; i < nfds; i++) {					   for (i = 0; i < nfds; i++) {
      if (!(conn = find_socks_request(ufds[i].fd, 1)))		      if (!(conn = find_socks_request(ufds[i].fd, 1)))
         continue;						         continue;

      ufds[i].events = conn->selectevents;			      ufds[i].events = conn->selectevents;
   }								   }

   return(nevents);						   return(nevents);
}								}

int close(CLOSE_SIGNATURE) {					int close(CLOSE_SIGNATURE) {
   int rc;							   int rc;
   struct connreq *conn;					   struct connreq *conn;

	if (realclose == NULL) {					if (realclose == NULL) {
		show_msg(MSGERR, "Unresolved symbol: close\n"			show_msg(MSGERR, "Unresolved symbol: close\n"
		return(-1);							return(-1);
	}								}

   show_msg(MSGDEBUG, "Call to close(%d)\n", fd);		   show_msg(MSGDEBUG, "Call to close(%d)\n", fd);

   rc = realclose(fd);						   rc = realclose(fd);

   /* If we have this fd in our request handling list we 	   /* If we have this fd in our request handling list we 
    * remove it now */						    * remove it now */
   if ((conn = find_socks_request(fd, 1))) {			   if ((conn = find_socks_request(fd, 1))) {
      show_msg(MSGDEBUG, "Call to close() received on file de	      show_msg(MSGDEBUG, "Call to close() received on file de
                         "%d which is a connection request of	                         "%d which is a connection request of
               conn->sockid, conn->state);			               conn->sockid, conn->state);
      kill_socks_request(conn);					      kill_socks_request(conn);
   }								   }

   return(rc);							   return(rc);
}								}

/* If we are not done setting up the connection yet, return	/* If we are not done setting up the connection yet, return
 * -1 and ENOTCONN, otherwise call getpeername			 * -1 and ENOTCONN, otherwise call getpeername
 *								 *
 * This is necessary since some applications, when using non-	 * This is necessary since some applications, when using non-
 * (like ircII) use getpeername() to find out if they are con	 * (like ircII) use getpeername() to find out if they are con
 *								 *
 * This results in races sometimes, where the client sends da	 * This results in races sometimes, where the client sends da
 * before we are done with the socks connection setup.  Anoth	 * before we are done with the socks connection setup.  Anoth
 * be to intercept send().					 * be to intercept send().
 * 								 * 
 * This could be extended to actually set the peername to the	 * This could be extended to actually set the peername to the
 * client application has requested, but not for now.		 * client application has requested, but not for now.
 *								 *
 * PP, Sat, 27 Mar 2004 11:30:23 +0100				 * PP, Sat, 27 Mar 2004 11:30:23 +0100
 */								 */
int getpeername(GETPEERNAME_SIGNATURE) {			int getpeername(GETPEERNAME_SIGNATURE) {
   struct connreq *conn;					   struct connreq *conn;
   int rc;							   int rc;

    if (realgetpeername == NULL) {				    if (realgetpeername == NULL) {
        show_msg(MSGERR, "Unresolved symbol: getpeername\n");	        show_msg(MSGERR, "Unresolved symbol: getpeername\n");
        return(-1);						        return(-1);
    }								    }

   show_msg(MSGDEBUG, "Call to getpeername for fd %d\n", __fd	   show_msg(MSGDEBUG, "Call to getpeername for fd %d\n", __fd


   rc = realgetpeername(__fd, __name, __namelen);		   rc = realgetpeername(__fd, __name, __namelen);
   if (rc == -1)						   if (rc == -1)
       return rc;						       return rc;

   /* Are we handling this connect? */				   /* Are we handling this connect? */
   if ((conn = find_socks_request(__fd, 1))) {			   if ((conn = find_socks_request(__fd, 1))) {
       /* While we are at it, we might was well try to do som	       /* While we are at it, we might was well try to do som
       handle_request(conn);					       handle_request(conn);

       if (conn->state != DONE) {				       if (conn->state != DONE) {
           errno = ENOTCONN;					           errno = ENOTCONN;
           return(-1);						           return(-1);
       }							       }
   }								   }
   return rc;							   return rc;
}								}

static struct connreq *new_socks_request(int sockid, struct s	static struct connreq *new_socks_request(int sockid, struct s
                                         struct sockaddr_in *	                                         struct sockaddr_in *
                                         struct serverent *pa	                                         struct serverent *pa
   struct connreq *newconn;					   struct connreq *newconn;

   if ((newconn = malloc(sizeof(*newconn))) == NULL) {		   if ((newconn = malloc(sizeof(*newconn))) == NULL) {
      /* Could not malloc, we're stuffed */			      /* Could not malloc, we're stuffed */
      show_msg(MSGERR, "Could not allocate memory for new soc	      show_msg(MSGERR, "Could not allocate memory for new soc
      return(NULL);						      return(NULL);
   }								   }

   /* Add this connection to be proxied to the list */		   /* Add this connection to be proxied to the list */
   memset(newconn, 0x0, sizeof(*newconn));			   memset(newconn, 0x0, sizeof(*newconn));
   newconn->sockid = sockid;					   newconn->sockid = sockid;
   newconn->state = UNSTARTED;					   newconn->state = UNSTARTED;
   newconn->path = path;					   newconn->path = path;
   memcpy(&(newconn->connaddr), connaddr, sizeof(newconn->con	   memcpy(&(newconn->connaddr), connaddr, sizeof(newconn->con
   memcpy(&(newconn->serveraddr), serveraddr, sizeof(newconn-	   memcpy(&(newconn->serveraddr), serveraddr, sizeof(newconn-
   newconn->next = requests;					   newconn->next = requests;
   requests = newconn;						   requests = newconn;
   								   
   return(newconn);						   return(newconn);
}								}

static void kill_socks_request(struct connreq *conn) {		static void kill_socks_request(struct connreq *conn) {
   struct connreq *connnode;					   struct connreq *connnode;

   if (requests == conn)					   if (requests == conn)
      requests = conn->next;					      requests = conn->next;
   else {							   else {
      for (connnode = requests; connnode != NULL; connnode = 	      for (connnode = requests; connnode != NULL; connnode = 
         if (connnode->next == conn) {				         if (connnode->next == conn) {
            connnode->next = conn->next;			            connnode->next = conn->next;
            break;						            break;
         }							         }
      }								      }
   }								   }

   free(conn);							   free(conn);
}								}

static struct connreq *find_socks_request(int sockid, int inc	static struct connreq *find_socks_request(int sockid, int inc
   struct connreq *connnode;					   struct connreq *connnode;

   for (connnode = requests; connnode != NULL; connnode = con	   for (connnode = requests; connnode != NULL; connnode = con
      if (connnode->sockid == sockid) {				      if (connnode->sockid == sockid) {
         if (((connnode->state == FAILED) || (connnode->state	         if (((connnode->state == FAILED) || (connnode->state
             !includefinished)					             !includefinished)
            break;						            break;
         else 							         else 
            return(connnode);					            return(connnode);
      }								      }
   }								   }

   return(NULL);						   return(NULL);
}								}

static int handle_request(struct connreq *conn) {		static int handle_request(struct connreq *conn) {
   int rc = 0;							   int rc = 0;
   int i = 0;							   int i = 0;

   show_msg(MSGDEBUG, "Beginning handle loop for socket %d\n"	   show_msg(MSGDEBUG, "Beginning handle loop for socket %d\n"

   while ((rc == 0) && 						   while ((rc == 0) && 
          (conn->state != FAILED) &&				          (conn->state != FAILED) &&
          (conn->state != DONE) && 				          (conn->state != DONE) && 
          (i++ < 20)) {						          (i++ < 20)) {
      show_msg(MSGDEBUG, "In request handle loop for socket %	      show_msg(MSGDEBUG, "In request handle loop for socket %
                         "current state of request is %d\n", 	                         "current state of request is %d\n", 
                         conn->state);				                         conn->state);
      switch(conn->state) {					      switch(conn->state) {
         case UNSTARTED:					         case UNSTARTED:
         case CONNECTING:					         case CONNECTING:
            rc = connect_server(conn);				            rc = connect_server(conn);
            break;						            break;
         case CONNECTED:					         case CONNECTED:
            rc = send_socks_request(conn);			            rc = send_socks_request(conn);
            break;						            break;
         case SENDING:						         case SENDING:
            rc = send_buffer(conn);				            rc = send_buffer(conn);
            break;						            break;
         case RECEIVING:					         case RECEIVING:
            rc = recv_buffer(conn);				            rc = recv_buffer(conn);
            break;						            break;
         case SENTV4REQ:					         case SENTV4REQ:
            show_msg(MSGDEBUG, "Receiving reply to SOCKS V4 c	            show_msg(MSGDEBUG, "Receiving reply to SOCKS V4 c
            conn->datalen = sizeof(struct sockrep);		            conn->datalen = sizeof(struct sockrep);
            conn->datadone = 0;					            conn->datadone = 0;
            conn->state = RECEIVING;				            conn->state = RECEIVING;
            conn->nextstate = GOTV4REQ;				            conn->nextstate = GOTV4REQ;
            break;						            break;
         case GOTV4REQ:						         case GOTV4REQ:
            rc = read_socksv4_req(conn);			            rc = read_socksv4_req(conn);
            break;						            break;
         case SENTV5METHOD:					         case SENTV5METHOD:
            show_msg(MSGDEBUG, "Receiving reply to SOCKS V5 m	            show_msg(MSGDEBUG, "Receiving reply to SOCKS V5 m
            conn->datalen = 2;					            conn->datalen = 2;
            conn->datadone = 0;					            conn->datadone = 0;
            conn->state = RECEIVING;				            conn->state = RECEIVING;
            conn->nextstate = GOTV5METHOD;			            conn->nextstate = GOTV5METHOD;
            break;						            break;
         case GOTV5METHOD:					         case GOTV5METHOD:
            rc = read_socksv5_method(conn);			            rc = read_socksv5_method(conn);
            break;						            break;
         case SENTV5AUTH:					         case SENTV5AUTH:
            show_msg(MSGDEBUG, "Receiving reply to SOCKS V5 a	            show_msg(MSGDEBUG, "Receiving reply to SOCKS V5 a
            conn->datalen = 2;					            conn->datalen = 2;
            conn->datadone = 0;					            conn->datadone = 0;
            conn->state = RECEIVING;				            conn->state = RECEIVING;
            conn->nextstate = GOTV5AUTH;			            conn->nextstate = GOTV5AUTH;
            break;						            break;
         case GOTV5AUTH:					         case GOTV5AUTH:
            rc = read_socksv5_auth(conn);			            rc = read_socksv5_auth(conn);
            break;						            break;
         case SENTV5CONNECT:					         case SENTV5CONNECT:
            show_msg(MSGDEBUG, "Receiving reply to SOCKS V5 c	            show_msg(MSGDEBUG, "Receiving reply to SOCKS V5 c
            conn->datalen = 10;					            conn->datalen = 10;
            conn->datadone = 0;					            conn->datadone = 0;
            conn->state = RECEIVING;				            conn->state = RECEIVING;
            conn->nextstate = GOTV5CONNECT;			            conn->nextstate = GOTV5CONNECT;
            break;						            break;
         case GOTV5CONNECT:					         case GOTV5CONNECT:
            rc = read_socksv5_connect(conn);			            rc = read_socksv5_connect(conn);
            break;						            break;
      }								      }

      conn->err = errno;					      conn->err = errno;
   }								   }

   if (i == 20)							   if (i == 20)
      show_msg(MSGERR, "Ooops, state loop while handling requ	      show_msg(MSGERR, "Ooops, state loop while handling requ
               conn->sockid);					               conn->sockid);

   show_msg(MSGDEBUG, "Handle loop completed for socket %d in	   show_msg(MSGDEBUG, "Handle loop completed for socket %d in
                      "returning %d\n", conn->sockid, conn->s	                      "returning %d\n", conn->sockid, conn->s
   return(rc);							   return(rc);
}								}

static int connect_server(struct connreq *conn) {		static int connect_server(struct connreq *conn) {
   int rc;							   int rc;

	/* Connect this socket to the socks server */			/* Connect this socket to the socks server */
   show_msg(MSGDEBUG, "Connecting to %s port %d\n", 		   show_msg(MSGDEBUG, "Connecting to %s port %d\n", 
            inet_ntoa(conn->serveraddr.sin_addr), ntohs(conn-	            inet_ntoa(conn->serveraddr.sin_addr), ntohs(conn-

   rc = realconnect(conn->sockid, (CONNECT_SOCKARG) &(conn->s	   rc = realconnect(conn->sockid, (CONNECT_SOCKARG) &(conn->s
                    sizeof(conn->serveraddr));			                    sizeof(conn->serveraddr));

   show_msg(MSGDEBUG, "Connect returned %d, errno is %d\n", r	   show_msg(MSGDEBUG, "Connect returned %d, errno is %d\n", r
   if (rc) {							   if (rc) {
      if (errno != EINPROGRESS) {				      if (errno != EINPROGRESS) {
         show_msg(MSGERR, "Error %d attempting to connect to 	         show_msg(MSGERR, "Error %d attempting to connect to 
                  "server (%s)\n", errno, strerror(errno));	                  "server (%s)\n", errno, strerror(errno));
         conn->state = FAILED;					         conn->state = FAILED;
      } else {							      } else {
         show_msg(MSGDEBUG, "Connection in progress\n");	         show_msg(MSGDEBUG, "Connection in progress\n");
         conn->state = CONNECTING;				         conn->state = CONNECTING;
      }								      }
   } else {							   } else {
      show_msg(MSGDEBUG, "Socket %d connected to SOCKS server	      show_msg(MSGDEBUG, "Socket %d connected to SOCKS server
      conn->state = CONNECTED;					      conn->state = CONNECTED;
   }								   }

   return((rc ? errno : 0));					   return((rc ? errno : 0));
}								}

static int send_socks_request(struct connreq *conn) {		static int send_socks_request(struct connreq *conn) {
	int rc = 0;							int rc = 0;

#ifdef USE_TOR_DNS						#ifdef USE_TOR_DNS
    if (conn->path->type == 4) {				    if (conn->path->type == 4) {
        char *name = get_pool_entry(pool, &(conn->connaddr.si	        char *name = get_pool_entry(pool, &(conn->connaddr.si
        if(name != NULL) {					        if(name != NULL) {
            rc = send_socksv4a_request(conn,name);		            rc = send_socksv4a_request(conn,name);
        } else {						        } else {
            rc = send_socksv4_request(conn);			            rc = send_socksv4_request(conn);
        }							        }
#else 								#else 
    if (conn->path->type == 4) {				    if (conn->path->type == 4) {
      rc = send_socksv4_request(conn);				      rc = send_socksv4_request(conn);
#endif								#endif
    } else {							    } else {
	  rc = send_socksv5_method(conn);				  rc = send_socksv5_method(conn);
	}								}
   return(rc);							   return(rc);
}								}			

#ifdef USE_TOR_DNS						#ifdef USE_TOR_DNS
static int send_socksv4a_request(struct connreq *conn,const c	static int send_socksv4a_request(struct connreq *conn,const c
{								{
  struct passwd *user;						  struct passwd *user;
  struct sockreq *thisreq;					  struct sockreq *thisreq;
  int endOfUser;						  int endOfUser;
  /* Determine the current username */				  /* Determine the current username */
  user = getpwuid(getuid());					  user = getpwuid(getuid());	

  thisreq = (struct sockreq *) conn->buffer;			  thisreq = (struct sockreq *) conn->buffer;
  endOfUser=sizeof(struct sockreq) +				  endOfUser=sizeof(struct sockreq) +
  (user == NULL ? 0 : strlen(user->pw_name)) + 1;		  (user == NULL ? 0 : strlen(user->pw_name)) + 1;

  /* Check the buffer has enough space for the request  */	  /* Check the buffer has enough space for the request  */
  /* and the user name                                  */	  /* and the user name                                  */
  conn->datalen = endOfUser+ 					  conn->datalen = endOfUser+ 
                  (onion_host == NULL ? 0 : strlen(onion_host	                  (onion_host == NULL ? 0 : strlen(onion_host
  if (sizeof(conn->buffer) < conn->datalen) {			  if (sizeof(conn->buffer) < conn->datalen) {
      show_msg(MSGERR, "The SOCKS username is too long");	      show_msg(MSGERR, "The SOCKS username is too long");
      conn->state = FAILED;					      conn->state = FAILED;
      return(ECONNREFUSED);					      return(ECONNREFUSED);
  }								  }

  /* Create the request */					  /* Create the request */
  thisreq->version = 4;						  thisreq->version = 4;
  thisreq->command = 1;						  thisreq->command = 1;
  thisreq->dstport = conn->connaddr.sin_port;			  thisreq->dstport = conn->connaddr.sin_port;
  thisreq->dstip   = htonl(1);					  thisreq->dstip   = htonl(1);

  /* Copy the username */					  /* Copy the username */
  strcpy((char *) thisreq + sizeof(struct sockreq), 		  strcpy((char *) thisreq + sizeof(struct sockreq), 
         (user == NULL ? "" : user->pw_name));			         (user == NULL ? "" : user->pw_name));

  /* Copy the onion host */					  /* Copy the onion host */
  strcpy((char *) thisreq + endOfUser,				  strcpy((char *) thisreq + endOfUser,
         (onion_host == NULL ? "" : onion_host));		         (onion_host == NULL ? "" : onion_host));

  conn->datadone = 0;						  conn->datadone = 0;
  conn->state = SENDING;					  conn->state = SENDING;
  conn->nextstate = SENTV4REQ;					  conn->nextstate = SENTV4REQ;

  return(0);   							  return(0);   
}								}
#endif /* USE_TOR_DNS */					#endif /* USE_TOR_DNS */

static int send_socksv4_request(struct connreq *conn) {		static int send_socksv4_request(struct connreq *conn) {
	struct passwd *user;						struct passwd *user;
	struct sockreq *thisreq;					struct sockreq *thisreq;
									
	/* Determine the current username */				/* Determine the current username */
	user = getpwuid(getuid());					user = getpwuid(getuid());	

   thisreq = (struct sockreq *) conn->buffer;			   thisreq = (struct sockreq *) conn->buffer;

   /* Check the buffer has enough space for the request  */	   /* Check the buffer has enough space for the request  */
   /* and the user name                                  */	   /* and the user name                                  */
   conn->datalen = sizeof(struct sockreq) + 			   conn->datalen = sizeof(struct sockreq) + 
                   (user == NULL ? 0 : strlen(user->pw_name))	                   (user == NULL ? 0 : strlen(user->pw_name))
   if (sizeof(conn->buffer) < conn->datalen) {			   if (sizeof(conn->buffer) < conn->datalen) {
      show_msg(MSGERR, "The SOCKS username is too long");	      show_msg(MSGERR, "The SOCKS username is too long");
      conn->state = FAILED;					      conn->state = FAILED;
      return(ECONNREFUSED);					      return(ECONNREFUSED);
   }								   }

	/* Create the request */					/* Create the request */
	thisreq->version = 4;						thisreq->version = 4;
	thisreq->command = 1;						thisreq->command = 1;
	thisreq->dstport = conn->connaddr.sin_port;			thisreq->dstport = conn->connaddr.sin_port;
	thisreq->dstip   = conn->connaddr.sin_addr.s_addr;		thisreq->dstip   = conn->connaddr.sin_addr.s_addr;

	/* Copy the username */						/* Copy the username */
	strcpy((char *) thisreq + sizeof(struct sockreq), 		strcpy((char *) thisreq + sizeof(struct sockreq), 
	       (user == NULL ? "" : user->pw_name));			       (user == NULL ? "" : user->pw_name));

   conn->datadone = 0;						   conn->datadone = 0;
   conn->state = SENDING;					   conn->state = SENDING;
   conn->nextstate = SENTV4REQ;					   conn->nextstate = SENTV4REQ;

	return(0);   							return(0);   
}								}			

static int send_socksv5_method(struct connreq *conn) {		static int send_socksv5_method(struct connreq *conn) {
   char verstring[] = { 0x05,    /* Version 5 SOCKS */		   char verstring[] = { 0x05,    /* Version 5 SOCKS */
                        0x02,    /* No. Methods     */		                        0x02,    /* No. Methods     */
                        0x00,    /* Null Auth       */		                        0x00,    /* Null Auth       */
                        0x02 };  /* User/Pass Auth  */		                        0x02 };  /* User/Pass Auth  */

   show_msg(MSGDEBUG, "Constructing V5 method negotiation\n")	   show_msg(MSGDEBUG, "Constructing V5 method negotiation\n")
   conn->state = SENDING;					   conn->state = SENDING;
   conn->nextstate = SENTV5METHOD;				   conn->nextstate = SENTV5METHOD;
   memcpy(conn->buffer, verstring, sizeof(verstring)); 		   memcpy(conn->buffer, verstring, sizeof(verstring)); 
   conn->datalen = sizeof(verstring);				   conn->datalen = sizeof(verstring);
   conn->datadone = 0;						   conn->datadone = 0;

   return(0);							   return(0);
}								}			

static int send_socksv5_connect(struct connreq *conn) {		static int send_socksv5_connect(struct connreq *conn) {
#ifdef USE_TOR_DNS						#ifdef USE_TOR_DNS
   int namelen = 0;						   int namelen = 0;
   char *name = NULL;						   char *name = NULL;
#endif								#endif
   char constring[] = { 0x05,    /* Version 5 SOCKS */		   char constring[] = { 0x05,    /* Version 5 SOCKS */
                        0x01,    /* Connect request */		                        0x01,    /* Connect request */
                        0x00,    /* Reserved        */		                        0x00,    /* Reserved        */
                        0x01 };  /* IP Version 4    */		                        0x01 };  /* IP Version 4    */

   show_msg(MSGDEBUG, "Constructing V5 connect request\n");	   show_msg(MSGDEBUG, "Constructing V5 connect request\n");
   conn->datadone = 0;						   conn->datadone = 0;
   conn->state = SENDING;					   conn->state = SENDING;
   conn->nextstate = SENTV5CONNECT;				   conn->nextstate = SENTV5CONNECT;
   memcpy(conn->buffer, constring, sizeof(constring)); 		   memcpy(conn->buffer, constring, sizeof(constring)); 
   conn->datalen = sizeof(constring);				   conn->datalen = sizeof(constring);

#ifdef USE_TOR_DNS						#ifdef USE_TOR_DNS
   show_msg(MSGDEBUG, "send_socksv5_connect: looking for: %s\	   show_msg(MSGDEBUG, "send_socksv5_connect: looking for: %s\
            inet_ntoa(conn->connaddr.sin_addr));		            inet_ntoa(conn->connaddr.sin_addr));

   name = get_pool_entry(pool, &(conn->connaddr.sin_addr));	   name = get_pool_entry(pool, &(conn->connaddr.sin_addr));
   if(name != NULL) {						   if(name != NULL) {
       namelen = strlen(name);					       namelen = strlen(name);
       if(namelen > 255) {  /* "Can't happen" */		       if(namelen > 255) {  /* "Can't happen" */
           name = NULL;						           name = NULL;
       }							       }
   }								   }
   if(name != NULL) {						   if(name != NULL) {
       show_msg(MSGDEBUG, "send_socksv5_connect: found it!\n"	       show_msg(MSGDEBUG, "send_socksv5_connect: found it!\n"
       /* Substitute the domain name from the pool into the S	       /* Substitute the domain name from the pool into the S
       conn->buffer[3] = 0x03;  /* Change the ATYP field */	       conn->buffer[3] = 0x03;  /* Change the ATYP field */
       conn->buffer[4] = namelen;  /* Length of name */		       conn->buffer[4] = namelen;  /* Length of name */
       conn->datalen++;						       conn->datalen++;
       memcpy(&conn->buffer[conn->datalen], name, namelen);	       memcpy(&conn->buffer[conn->datalen], name, namelen);
       conn->datalen += namelen;				       conn->datalen += namelen;
   } else {							   } else {
       show_msg(MSGDEBUG, "send_socksv5_connect: ip address n	       show_msg(MSGDEBUG, "send_socksv5_connect: ip address n
#endif								#endif
       /* Use the raw IP address */				       /* Use the raw IP address */
       memcpy(&conn->buffer[conn->datalen], &(conn->connaddr.	       memcpy(&conn->buffer[conn->datalen], &(conn->connaddr.
              sizeof(conn->connaddr.sin_addr.s_addr));		              sizeof(conn->connaddr.sin_addr.s_addr));
       conn->datalen += sizeof(conn->connaddr.sin_addr.s_addr	       conn->datalen += sizeof(conn->connaddr.sin_addr.s_addr
#ifdef USE_TOR_DNS						#ifdef USE_TOR_DNS
   }								   }
#endif								#endif
   memcpy(&conn->buffer[conn->datalen], &(conn->connaddr.sin_	   memcpy(&conn->buffer[conn->datalen], &(conn->connaddr.sin_
        sizeof(conn->connaddr.sin_port));			        sizeof(conn->connaddr.sin_port));
   conn->datalen += sizeof(conn->connaddr.sin_port);		   conn->datalen += sizeof(conn->connaddr.sin_port);

   return(0);							   return(0);
}								}			

static int send_buffer(struct connreq *conn) {			static int send_buffer(struct connreq *conn) {
   int rc = 0;							   int rc = 0;

   show_msg(MSGDEBUG, "Writing to server (sending %d bytes)\n	   show_msg(MSGDEBUG, "Writing to server (sending %d bytes)\n
   while ((rc == 0) && (conn->datadone != conn->datalen)) {	   while ((rc == 0) && (conn->datadone != conn->datalen)) {
      rc = send(conn->sockid, conn->buffer + conn->datadone, 	      rc = send(conn->sockid, conn->buffer + conn->datadone, 
                conn->datalen - conn->datadone, 0);		                conn->datalen - conn->datadone, 0);
      if (rc > 0) {						      if (rc > 0) {
         conn->datadone += rc;					         conn->datadone += rc;
         rc = 0;						         rc = 0;
      } else {							      } else {
         if (errno != EWOULDBLOCK)				         if (errno != EWOULDBLOCK)
            show_msg(MSGDEBUG, "Write failed, %s\n", strerror	            show_msg(MSGDEBUG, "Write failed, %s\n", strerror
         rc = errno;						         rc = errno;
      }								      }
   }								   }

   if (conn->datadone == conn->datalen)				   if (conn->datadone == conn->datalen)
      conn->state = conn->nextstate;				      conn->state = conn->nextstate;

   show_msg(MSGDEBUG, "Sent %d bytes of %d bytes in buffer, r	   show_msg(MSGDEBUG, "Sent %d bytes of %d bytes in buffer, r
            conn->datadone, conn->datalen, rc);			            conn->datadone, conn->datalen, rc);
   return(rc);							   return(rc);
}								}

static int recv_buffer(struct connreq *conn) {			static int recv_buffer(struct connreq *conn) {
   int rc = 0;							   int rc = 0;

   show_msg(MSGDEBUG, "Reading from server (expecting %d byte	   show_msg(MSGDEBUG, "Reading from server (expecting %d byte
   while ((rc == 0) && (conn->datadone != conn->datalen)) {	   while ((rc == 0) && (conn->datadone != conn->datalen)) {
      rc = recv(conn->sockid, conn->buffer + conn->datadone, 	      rc = recv(conn->sockid, conn->buffer + conn->datadone, 
                conn->datalen - conn->datadone, 0);		                conn->datalen - conn->datadone, 0);
      if (rc > 0) {						      if (rc > 0) {
         conn->datadone += rc;					         conn->datadone += rc;
         rc = 0;						         rc = 0;
      } else if (rc == 0) {					      } else if (rc == 0) {
         show_msg(MSGDEBUG, "Peer has shutdown but we only re	         show_msg(MSGDEBUG, "Peer has shutdown but we only re
            conn->datadone, conn->datalen);			            conn->datadone, conn->datalen);
         rc = ENOTCONN; /* ENOTCONN seems like the most fitti	         rc = ENOTCONN; /* ENOTCONN seems like the most fitti
      } else {							      } else {
         if (errno != EWOULDBLOCK)				         if (errno != EWOULDBLOCK)
            show_msg(MSGDEBUG, "Read failed, %s\n", strerror(	            show_msg(MSGDEBUG, "Read failed, %s\n", strerror(
         rc = errno;						         rc = errno;
      }								      }
   }								   }

   if (conn->datadone == conn->datalen)				   if (conn->datadone == conn->datalen)
      conn->state = conn->nextstate;				      conn->state = conn->nextstate;

   show_msg(MSGDEBUG, "Received %d bytes of %d bytes expected	   show_msg(MSGDEBUG, "Received %d bytes of %d bytes expected
            conn->datadone, conn->datalen, rc);			            conn->datadone, conn->datalen, rc);
   return(rc);							   return(rc);
}								}

static int read_socksv5_method(struct connreq *conn) {		static int read_socksv5_method(struct connreq *conn) {
	struct passwd *nixuser;						struct passwd *nixuser;
	char *uname, *upass;						char *uname, *upass;

	/* See if we offered an acceptable method */			/* See if we offered an acceptable method */
	if (conn->buffer[1] == '\xff') {				if (conn->buffer[1] == '\xff') {
		show_msg(MSGERR, "SOCKS V5 server refused aut			show_msg(MSGERR, "SOCKS V5 server refused aut
      conn->state = FAILED;					      conn->state = FAILED;
		return(ECONNREFUSED);						return(ECONNREFUSED);
	}								}

	/* If the socks server chose username/password authen		/* If the socks server chose username/password authen
	/* (method 2) then do that                           		/* (method 2) then do that                           
	if ((unsigned short int) conn->buffer[1] == 2) {		if ((unsigned short int) conn->buffer[1] == 2) {
		show_msg(MSGDEBUG, "SOCKS V5 server chose use			show_msg(MSGDEBUG, "SOCKS V5 server chose use

		/* Determine the current *nix username */			/* Determine the current *nix username */
		nixuser = getpwuid(getuid());					nixuser = getpwuid(getuid());	

		if (((uname = conn->path->defuser) == NULL) &			if (((uname = conn->path->defuser) == NULL) &
          ((uname = getenv("TSOCKS_USERNAME")) == NULL) &&	          ((uname = getenv("TSOCKS_USERNAME")) == NULL) &&
		    ((uname = (nixuser == NULL ? NULL : nixus			    ((uname = (nixuser == NULL ? NULL : nixus
			show_msg(MSGERR, "Could not get SOCKS				show_msg(MSGERR, "Could not get SOCKS
				   "local passwd file, tsocks					   "local passwd file, tsocks
				   "or $TSOCKS_USERNAME to au					   "or $TSOCKS_USERNAME to au
				   "with"); 							   "with"); 
         conn->state = FAILED;					         conn->state = FAILED;
			return(ECONNREFUSED);						return(ECONNREFUSED);
		} 								} 

		if (((upass = getenv("TSOCKS_PASSWORD")) == N			if (((upass = getenv("TSOCKS_PASSWORD")) == N
          ((upass = conn->path->defpass) == NULL)) {		          ((upass = conn->path->defpass) == NULL)) {
			show_msg(MSGERR, "Need a password in 				show_msg(MSGERR, "Need a password in 
				   "$TSOCKS_PASSWORD to authe					   "$TSOCKS_PASSWORD to authe
         conn->state = FAILED;					         conn->state = FAILED;
			return(ECONNREFUSED);						return(ECONNREFUSED);
		} 								} 

		/* Check that the username / pass specified w			/* Check that the username / pass specified w
		/* fit into the buffer						/* fit into the buffer			
		if ((3 + strlen(uname) + strlen(upass)) >= si			if ((3 + strlen(uname) + strlen(upass)) >= si
			show_msg(MSGERR, "The supplied socks 				show_msg(MSGERR, "The supplied socks 
				   "password is too long");					   "password is too long");
         conn->state = FAILED;					         conn->state = FAILED;
			return(ECONNREFUSED);						return(ECONNREFUSED);
		}								}
										
		conn->datalen = 0;						conn->datalen = 0;
		conn->buffer[conn->datalen] = '\x01';				conn->buffer[conn->datalen] = '\x01';
		conn->datalen++;						conn->datalen++;
		conn->buffer[conn->datalen] = (int8_t) strlen			conn->buffer[conn->datalen] = (int8_t) strlen
		conn->datalen++;						conn->datalen++;
		memcpy(&(conn->buffer[conn->datalen]), uname,			memcpy(&(conn->buffer[conn->datalen]), uname,
		conn->datalen = conn->datalen + strlen(uname)			conn->datalen = conn->datalen + strlen(uname)
		conn->buffer[conn->datalen] = (int8_t) strlen			conn->buffer[conn->datalen] = (int8_t) strlen
		conn->datalen++;						conn->datalen++;
		memcpy(&(conn->buffer[conn->datalen]), upass,			memcpy(&(conn->buffer[conn->datalen]), upass,
		conn->datalen = conn->datalen + strlen(upass)			conn->datalen = conn->datalen + strlen(upass)

      conn->state = SENDING;					      conn->state = SENDING;
      conn->nextstate = SENTV5AUTH;				      conn->nextstate = SENTV5AUTH;
      conn->datadone = 0;					      conn->datadone = 0;
	} else								} else
      return(send_socksv5_connect(conn));			      return(send_socksv5_connect(conn));

   return(0);							   return(0);
}								}

static int read_socksv5_auth(struct connreq *conn) {		static int read_socksv5_auth(struct connreq *conn) {

   if (conn->buffer[1] != '\x00') {				   if (conn->buffer[1] != '\x00') {
      show_msg(MSGERR, "SOCKS authentication failed, check us	      show_msg(MSGERR, "SOCKS authentication failed, check us
      conn->state = FAILED;					      conn->state = FAILED;
      return(ECONNREFUSED);					      return(ECONNREFUSED);
   }								   }
										
   /* Ok, we authenticated ok, send the connection request */	   /* Ok, we authenticated ok, send the connection request */
   return(send_socksv5_connect(conn));				   return(send_socksv5_connect(conn));
}								}

static int read_socksv5_connect(struct connreq *conn) {		static int read_socksv5_connect(struct connreq *conn) {

	/* See if the connection succeeded */				/* See if the connection succeeded */
	if (conn->buffer[1] != '\x00') {				if (conn->buffer[1] != '\x00') {
		show_msg(MSGERR, "SOCKS V5 connect failed: ")			show_msg(MSGERR, "SOCKS V5 connect failed: ")
      conn->state = FAILED;					      conn->state = FAILED;
		switch ((int8_t) conn->buffer[1]) {				switch ((int8_t) conn->buffer[1]) {
			case 1:								case 1:
				show_msg(MSGERR, "General SOC					show_msg(MSGERR, "General SOC
				return(ECONNABORTED);						return(ECONNABORTED);
			case 2:								case 2:
				show_msg(MSGERR, "Connection 					show_msg(MSGERR, "Connection 
				return(ECONNABORTED);						return(ECONNABORTED);
			case 3:								case 3:
				show_msg(MSGERR, "Network unr					show_msg(MSGERR, "Network unr
				return(ENETUNREACH);						return(ENETUNREACH);
			case 4:								case 4:
				show_msg(MSGERR, "Host unreac					show_msg(MSGERR, "Host unreac
				return(EHOSTUNREACH);						return(EHOSTUNREACH);
			case 5:								case 5:
				show_msg(MSGERR, "Connection 					show_msg(MSGERR, "Connection 
				return(ECONNREFUSED);						return(ECONNREFUSED);
			case 6: 							case 6: 
				show_msg(MSGERR, "TTL Expired					show_msg(MSGERR, "TTL Expired
				return(ETIMEDOUT);						return(ETIMEDOUT);
			case 7:								case 7:
				show_msg(MSGERR, "Command not					show_msg(MSGERR, "Command not
				return(ECONNABORTED);						return(ECONNABORTED);
			case 8:								case 8:
				show_msg(MSGERR, "Address typ					show_msg(MSGERR, "Address typ
				return(ECONNABORTED);						return(ECONNABORTED);
			default:							default:
				show_msg(MSGERR, "Unknown err					show_msg(MSGERR, "Unknown err
				return(ECONNABORTED);						return(ECONNABORTED);
		}								}	
	} 								} 

   conn->state = DONE;						   conn->state = DONE;

   return(0);							   return(0);
}								}

static int read_socksv4_req(struct connreq *conn) {		static int read_socksv4_req(struct connreq *conn) {
   struct sockrep *thisrep;					   struct sockrep *thisrep;

   thisrep = (struct sockrep *) conn->buffer;			   thisrep = (struct sockrep *) conn->buffer;

   if (thisrep->result != 90) {					   if (thisrep->result != 90) {
      show_msg(MSGERR, "SOCKS V4 connect rejected:\n");		      show_msg(MSGERR, "SOCKS V4 connect rejected:\n");
      conn->state = FAILED;					      conn->state = FAILED;
      switch(thisrep->result) {					      switch(thisrep->result) {
         case 91:						         case 91:
            show_msg(MSGERR, "SOCKS server refused connection	            show_msg(MSGERR, "SOCKS server refused connection
            return(ECONNREFUSED);				            return(ECONNREFUSED);
         case 92:						         case 92:
            show_msg(MSGERR, "SOCKS server refused connection	            show_msg(MSGERR, "SOCKS server refused connection
                  "because of failed connect to identd "	                  "because of failed connect to identd "
                  "on this machine\n");				                  "on this machine\n");
            return(ECONNREFUSED);				            return(ECONNREFUSED);
         case 93:						         case 93:
            show_msg(MSGERR, "SOCKS server refused connection	            show_msg(MSGERR, "SOCKS server refused connection
                  "because identd and this library "		                  "because identd and this library "
                  "reported different user-ids\n");		                  "reported different user-ids\n");
            return(ECONNREFUSED);				            return(ECONNREFUSED);
         default:						         default:
            show_msg(MSGERR, "Unknown reason\n");		            show_msg(MSGERR, "Unknown reason\n");
            return(ECONNREFUSED);				            return(ECONNREFUSED);
      }								      }
   }								   }

   conn->state = DONE;						   conn->state = DONE;

   return(0);							   return(0);
}								}

#ifdef USE_SOCKS_DNS						#ifdef USE_SOCKS_DNS
int res_init(void) {						int res_init(void) {
        int rc;							        int rc;

	if (realresinit == NULL) {					if (realresinit == NULL) {
		show_msg(MSGERR, "Unresolved symbol: res_init			show_msg(MSGERR, "Unresolved symbol: res_init
		return(-1);							return(-1);
	}								}
        							        
	/* Call normal res_init */					/* Call normal res_init */
	rc = realresinit();						rc = realresinit();

   /* Force using TCP protocol for DNS queries */		   /* Force using TCP protocol for DNS queries */
   _res.options |= RES_USEVC;					   _res.options |= RES_USEVC;

   return(rc);							   return(rc);
}								}
#endif								#endif

#ifdef USE_TOR_DNS						#ifdef USE_TOR_DNS
static int deadpool_init()				      |	static int deadpool_init(void)
{								{
  if(!pool) {							  if(!pool) {
      get_environment();					      get_environment();
      get_config();						      get_config();
      if(config->tordns_enabled) {				      if(config->tordns_enabled) {
          pool = init_pool(					          pool = init_pool(
              config->tordns_cache_size, 			              config->tordns_cache_size, 
              config->tordns_deadpool_range->localip, 		              config->tordns_deadpool_range->localip, 
              config->tordns_deadpool_range->localnet, 		              config->tordns_deadpool_range->localnet, 
              config->defaultserver.address,			              config->defaultserver.address,
              config->defaultserver.port			              config->defaultserver.port
          );							          );
          if(!pool) {						          if(!pool) {
              show_msg(MSGERR, "failed to initialize deadpool	              show_msg(MSGERR, "failed to initialize deadpool
          }							          }
      }								      }
  }								  }
  return 0;							  return 0;
}								}

struct hostent *gethostbyname(GETHOSTBYNAME_SIGNATURE)		struct hostent *gethostbyname(GETHOSTBYNAME_SIGNATURE)
{								{
  if(pool) {							  if(pool) {
      return our_gethostbyname(pool, name);			      return our_gethostbyname(pool, name);
  } else {							  } else {
      return realgethostbyname(name);				      return realgethostbyname(name);
  }  								  }  
}								}

int getaddrinfo(GETADDRINFO_SIGNATURE)				int getaddrinfo(GETADDRINFO_SIGNATURE)
{								{
  if(pool) {							  if(pool) {
      return our_getaddrinfo(pool, node, service, hints, res)	      return our_getaddrinfo(pool, node, service, hints, res)
  } else {							  } else {
      return realgetaddrinfo(node, service, hints, res);	      return realgetaddrinfo(node, service, hints, res);
  }								  }
}								}

struct hostent *getipnodebyname(GETIPNODEBYNAME_SIGNATURE)	struct hostent *getipnodebyname(GETIPNODEBYNAME_SIGNATURE)
{								{
  if(pool) {							  if(pool) {
      return our_getipnodebyname(pool, name, af, flags, error	      return our_getipnodebyname(pool, name, af, flags, error
  } else {							  } else {
      return realgetipnodebyname(name, af, flags, error_num);	      return realgetipnodebyname(name, af, flags, error_num);
  }								  }
}								}

#endif 								#endif 

Only in /home/robert/Development/tork/src/tsocks/: tsocks.c.rej
Only in .: tsocks.conf.5
diff -y -x Makefile.am -x Makefile.in -x configure -x INSTALL -x README.TORDNS -x COPYING -x Changelog -x Doxyfile -x FAQ -x TODO ./tsocks.conf.complex.example /home/robert/Development/tork/src/tsocks/tsocks.conf.complex.example
# This is the configuration for libtsocks (transparent socks)	# This is the configuration for libtsocks (transparent socks)
# Lines beginning with # and blank lines are ignored		# Lines beginning with # and blank lines are ignored
#								#
# The basic idea is to specify:					# The basic idea is to specify:
#	- Local subnets - Networks that can be accessed direc	#	- Local subnets - Networks that can be accessed direc
#			  assistance from a socks server	#			  assistance from a socks server
#	- Paths - Paths are basically lists of networks and a	#	- Paths - Paths are basically lists of networks and a
#		  which can be used to reach these networks	#		  which can be used to reach these networks
#	- Default server - A socks server which should be use	#	- Default server - A socks server which should be use
#			   networks for which no path is avai	#			   networks for which no path is avai
# Much more documentation than provided in these comments can	# Much more documentation than provided in these comments can
# the man pages, tsocks(8) and tsocks.conf(8)			# the man pages, tsocks(8) and tsocks.conf(8)

# Local networks						# Local networks
# For this example this machine can directly access 192.168.0	# For this example this machine can directly access 192.168.0
# (192.168.0.*) and 10.0.0.0/255.0.0.0 (10.*)			# (192.168.0.*) and 10.0.0.0/255.0.0.0 (10.*)

local = 192.168.0.0/255.255.255.0				local = 192.168.0.0/255.255.255.0
local = 10.0.0.0/255.0.0.0					local = 10.0.0.0/255.0.0.0

# Paths								# Paths
# For this example this machine needs to access 150.0.0.0/255	# For this example this machine needs to access 150.0.0.0/255
# well as port 80 on the network 150.1.0.0/255.255.0.0 throug	# well as port 80 on the network 150.1.0.0/255.255.0.0 throug
# the socks 5 server at 10.1.7.25 (if this machines hostname 	# the socks 5 server at 10.1.7.25 (if this machines hostname 
# "socks.hello.com" we could also specify that, unless --disa	# "socks.hello.com" we could also specify that, unless --disa
# was specified to ./configure).				# was specified to ./configure).

path {								path {
	reaches = 150.0.0.0/255.255.0.0					reaches = 150.0.0.0/255.255.0.0
	reaches = 150.1.0.0:80/255.255.0.0				reaches = 150.1.0.0:80/255.255.0.0
	server = 10.1.7.25						server = 10.1.7.25
	server_type = 5							server_type = 5
	default_user = delius						default_user = delius
	default_pass = hello						default_pass = hello
}								}

# Default server						# Default server
# For connections that aren't to the local subnets or to 150.	# For connections that aren't to the local subnets or to 150.
# the server at 192.168.0.1 should be used (again, hostnames 	# the server at 192.168.0.1 should be used (again, hostnames 
# too, see note above)						# too, see note above)

server = 192.168.0.1						server = 192.168.0.1
# Server type defaults to 4 so we need to specify it as 5 for	# Server type defaults to 4 so we need to specify it as 5 for
server_type = 5							server_type = 5
# The port defaults to 1080 but I've stated it here for clari	# The port defaults to 1080 but I've stated it here for clari
server_port = 1080 						server_port = 1080 

diff -y -x Makefile.am -x Makefile.in -x configure -x INSTALL -x README.TORDNS -x COPYING -x Changelog -x Doxyfile -x FAQ -x TODO ./tsocks.conf.simple.example /home/robert/Development/tork/src/tsocks/tsocks.conf.simple.example
# This is the configuration for libtsocks (transparent socks)	# This is the configuration for libtsocks (transparent socks)
# Lines beginning with # and blank lines are ignored		# Lines beginning with # and blank lines are ignored
#								#
# This sample configuration shows the simplest (and most comm	# This sample configuration shows the simplest (and most comm
# tsocks. This is a basic LAN, this machine can access anythi	# tsocks. This is a basic LAN, this machine can access anythi
# local ethernet (192.168.0.*) but anything else has to use t	# local ethernet (192.168.0.*) but anything else has to use t
# 4 server on the firewall. Further details can be found in t	# 4 server on the firewall. Further details can be found in t
# tsocks(8) and tsocks.conf(5) and a more complex example is 	# tsocks(8) and tsocks.conf(5) and a more complex example is 
# tsocks.conf.complex.example					# tsocks.conf.complex.example

# We can access 192.168.0.* directly				# We can access 192.168.0.* directly
local = 192.168.0.0/255.255.255.0				local = 192.168.0.0/255.255.255.0

# Otherwise we use the server					# Otherwise we use the server
server = 192.168.0.1						server = 192.168.0.1

Only in /home/robert/Development/tork/src/tsocks/: tsocks.c~
diff -y -x Makefile.am -x Makefile.in -x configure -x INSTALL -x README.TORDNS -x COPYING -x Changelog -x Doxyfile -x FAQ -x TODO ./tsocks.h /home/robert/Development/tork/src/tsocks/tsocks.h
/* tsocks.h - Structures used by tsocks to form SOCKS request	/* tsocks.h - Structures used by tsocks to form SOCKS request

#ifndef _TSOCKS_H						#ifndef _TSOCKS_H

#define _TSOCKS_H	1					#define _TSOCKS_H	1

#include <parser.h>						#include <parser.h>

/* Structure representing a socks connection request */		/* Structure representing a socks connection request */
struct sockreq {						struct sockreq {
   int8_t version;						   int8_t version;
   int8_t command;						   int8_t command;
   int16_t dstport;						   int16_t dstport;
   int32_t dstip;						   int32_t dstip;
   /* A null terminated username goes here */			   /* A null terminated username goes here */
};								};

/* Structure representing a socks connection request response	/* Structure representing a socks connection request response
struct sockrep {						struct sockrep {
   int8_t version;						   int8_t version;
   int8_t result;						   int8_t result;
   int16_t ignore1;						   int16_t ignore1;
   int32_t ignore2;						   int32_t ignore2;
};								};

/* Structure representing a socket which we are currently pro	/* Structure representing a socket which we are currently pro
struct connreq {						struct connreq {
   /* Information about the socket and target */		   /* Information about the socket and target */
   int sockid;							   int sockid;
   struct sockaddr_in connaddr;					   struct sockaddr_in connaddr;
   struct sockaddr_in serveraddr;				   struct sockaddr_in serveraddr;

   /* Pointer to the config entry for the socks server */	   /* Pointer to the config entry for the socks server */
   struct serverent *path;					   struct serverent *path;

   /* Current state of this proxied socket */			   /* Current state of this proxied socket */
   int state;							   int state;

   /* Next state to go to when the send or receive is finishe	   /* Next state to go to when the send or receive is finishe
   int nextstate;						   int nextstate;

   /* When connections fail but an error number cannot be rep	   /* When connections fail but an error number cannot be rep
    * because the socket is non blocking we keep the connreq 	    * because the socket is non blocking we keep the connreq 
    * the status is queried with connect() again, we then ret	    * the status is queried with connect() again, we then ret
    * this value */						    * this value */
   int err;							   int err;

   /* Events that were set for this socket upon call to selec	   /* Events that were set for this socket upon call to selec
    * poll() */							    * poll() */
   int selectevents;						   int selectevents;

   /* Buffer for sending and receiving on the socket */		   /* Buffer for sending and receiving on the socket */
   int datalen;						      |	   unsigned int datalen;
   int datadone;					      |	   unsigned int datadone;
   char buffer[2048];						   char buffer[2048];

   struct connreq *next;					   struct connreq *next;
};								};

/* Connection statuses */					/* Connection statuses */
#define UNSTARTED 0						#define UNSTARTED 0
#define CONNECTING 1						#define CONNECTING 1
#define CONNECTED 2						#define CONNECTED 2
#define SENDING 3						#define SENDING 3
#define RECEIVING 4						#define RECEIVING 4
#define SENTV4REQ 5						#define SENTV4REQ 5
#define GOTV4REQ 6 						#define GOTV4REQ 6 
#define SENTV5METHOD 7 						#define SENTV5METHOD 7 
#define GOTV5METHOD 8						#define GOTV5METHOD 8
#define SENTV5AUTH 9						#define SENTV5AUTH 9
#define GOTV5AUTH 10						#define GOTV5AUTH 10
#define SENTV5CONNECT 11					#define SENTV5CONNECT 11
#define GOTV5CONNECT 12						#define GOTV5CONNECT 12
#define DONE 13 						#define DONE 13 
#define FAILED 14 						#define FAILED 14 
   								   
/* Flags to indicate what events a socket was select()ed for 	/* Flags to indicate what events a socket was select()ed for 
#define READ (1<<0)						#define READ (1<<0)
#define WRITE (1<<1)						#define WRITE (1<<1)
#define EXCEPT (1<<2)						#define EXCEPT (1<<2)
#define READWRITE (READ|WRITE)					#define READWRITE (READ|WRITE)
#define READWRITEEXCEPT (READ|WRITE|EXCEPT)			#define READWRITEEXCEPT (READ|WRITE|EXCEPT)

#endif								#endif
Only in .: tsocks.kdevelop
Only in .: tsocks.kdevelop.pcs
Only in .: tsocks.kdevses
Only in /home/robert/Development/tork/src/tsocks/: tsocks.lo
diff -y -x Makefile.am -x Makefile.in -x configure -x INSTALL -x README.TORDNS -x COPYING -x Changelog -x Doxyfile -x FAQ -x TODO ./validateconf.c /home/robert/Development/tork/src/tsocks/validateconf.c
/*								/*

    VALIDATECONF - Part of the tsocks package			    VALIDATECONF - Part of the tsocks package
		   This utility can be used to validate the t			   This utility can be used to validate the t
		   configuration file						   configuration file

    Copyright (C) 2000 Shaun Clowes 				    Copyright (C) 2000 Shaun Clowes 

    This program is free software; you can redistribute it an	    This program is free software; you can redistribute it an
    it under the terms of the GNU General Public License as p	    it under the terms of the GNU General Public License as p
    the Free Software Foundation; either version 2 of the Lic	    the Free Software Foundation; either version 2 of the Lic
    (at your option) any later version.				    (at your option) any later version.

    This program is distributed in the hope that it will be u	    This program is distributed in the hope that it will be u
    but WITHOUT ANY WARRANTY; without even the implied warran	    but WITHOUT ANY WARRANTY; without even the implied warran
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See	    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
    GNU General Public License for more details.		    GNU General Public License for more details.

    You should have received a copy of the GNU General Public	    You should have received a copy of the GNU General Public
    along with this program; if not, write to the Free Softwa	    along with this program; if not, write to the Free Softwa
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.	    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

*/								*/

/* Global configuration variables */ 				/* Global configuration variables */ 
char *progname = "validateconf";	      /* Name for err |	const char *progname = "validateconf";	      /* Name for err

/* Header Files */						/* Header Files */
#include <config.h>					      |	#include "../../config.h"
#include <stdio.h>						#include <stdio.h>
#include <stdlib.h>						#include <stdlib.h>
#include <unistd.h>						#include <unistd.h>
#include <sys/types.h>						#include <sys/types.h>
#include <sys/socket.h>						#include <sys/socket.h>
#include <string.h>						#include <string.h>
							      >	#include <sys/types.h>
#include <netinet/in.h>						#include <netinet/in.h>
#include <arpa/inet.h>						#include <arpa/inet.h>
#include <errno.h>						#include <errno.h>
#include <common.h>						#include <common.h>
#include <parser.h>						#include <parser.h>

void show_server(struct parsedfile *, struct serverent *, int	void show_server(struct parsedfile *, struct serverent *, int
void show_conf(struct parsedfile *config);			void show_conf(struct parsedfile *config);
void test_host(struct parsedfile *config, char *);		void test_host(struct parsedfile *config, char *);

int main(int argc, char *argv[]) {				int main(int argc, char *argv[]) {
	char *usage = "Usage: [-f conf file] [-t hostname/ip[ |		const char *usage = "Usage: [-f conf file] [-t hostna
	char *filename = NULL;						char *filename = NULL;
	char *testhost = NULL;						char *testhost = NULL;
   struct parsedfile config;					   struct parsedfile config;
	int i;								int i;

	if ((argc > 5) || (((argc - 1) % 2) != 0)) {			if ((argc > 5) || (((argc - 1) % 2) != 0)) {
		show_msg(MSGERR, "Invalid number of arguments			show_msg(MSGERR, "Invalid number of arguments
		show_msg(MSGERR, "%s\n", usage);				show_msg(MSGERR, "%s\n", usage);
		exit(1);							exit(1);
	}								}

	for (i = 1; i < argc; i = i + 2) {				for (i = 1; i < argc; i = i + 2) {
		if (!strcmp(argv[i], "-f")) {					if (!strcmp(argv[i], "-f")) {
			filename = argv[(i + 1)];					filename = argv[(i + 1)];
		} else if (!strcmp(argv[i], "-t")) {				} else if (!strcmp(argv[i], "-t")) {
			testhost = argv[(i + 1)];					testhost = argv[(i + 1)];
		} else {							} else {
			show_msg(MSGERR, "Unknown option %s\n				show_msg(MSGERR, "Unknown option %s\n
			show_msg(MSGERR, "%s\n", usage);				show_msg(MSGERR, "%s\n", usage);
			exit(1);							exit(1);
		}								}
	}								}

	if (!filename) 							if (!filename) 
		filename = strdup(CONF_FILE);					filename = strdup(CONF_FILE);

	printf("Reading configuration file %s...\n", filename		printf("Reading configuration file %s...\n", filename
	if (read_config(filename, &config) == 0)			if (read_config(filename, &config) == 0)
		printf("... Read complete\n\n");				printf("... Read complete\n\n");
	else 								else 
		exit(1);							exit(1);

	/* If they specified a test host, test it, otherwise 		/* If they specified a test host, test it, otherwise 
	/* dump the configuration                            		/* dump the configuration                            
	if (!testhost)							if (!testhost)
		show_conf(&config);						show_conf(&config);
	else								else
		test_host(&config, testhost);					test_host(&config, testhost);
									
	return(0);  							return(0);  
}								}

void test_host(struct parsedfile *config, char *host) { 	void test_host(struct parsedfile *config, char *host) { 
	struct in_addr hostaddr;					struct in_addr hostaddr;
	struct serverent *path;						struct serverent *path;
   char *hostname, *port;					   char *hostname, *port;
   char separator;						   char separator;
   unsigned long portno = 0;					   unsigned long portno = 0;

   /* See if a port has been specified */			   /* See if a port has been specified */
   hostname = strsplit(&separator, &host, ": \t\n");		   hostname = strsplit(&separator, &host, ": \t\n");
   if (separator == ':') {					   if (separator == ':') {
      port = strsplit(NULL, &host, " \t\n");			      port = strsplit(NULL, &host, " \t\n");
      if (port) 						      if (port) 
         portno = strtol(port, NULL, 0);			         portno = strtol(port, NULL, 0);
   }								   }

	/* First resolve the host to an ip */				/* First resolve the host to an ip */
	if ((hostaddr.s_addr = resolve_ip(hostname, 0, 1)) == |		if ((hostaddr.s_addr = resolve_ip(hostname, 0, 1)) ==
		fprintf(stderr, "Error: Cannot resolve %s\n",			fprintf(stderr, "Error: Cannot resolve %s\n",
		return;								return;
	} else {							} else {
		printf("Finding path for %s...\n", inet_ntoa(			printf("Finding path for %s...\n", inet_ntoa(
      if (!(is_local(config, &(hostaddr)))) {			      if (!(is_local(config, &(hostaddr)))) {
         printf("Path is local\n");				         printf("Path is local\n");
      } else {							      } else {
         pick_server(config, &path, &hostaddr, portno);		         pick_server(config, &path, &hostaddr, portno);
         if (path == &(config->defaultserver)) {		         if (path == &(config->defaultserver)) {
            printf("Path is via default server:\n");		            printf("Path is via default server:\n");
            show_server(config, path, 1);			            show_server(config, path, 1);
         } else {						         } else {
            printf("Host is reached via this path:\n");		            printf("Host is reached via this path:\n");
            show_server(config, path, 0);			            show_server(config, path, 0);
         }							         }
      }								      }
	}								}

	return;								return;
}								}

void show_conf(struct parsedfile *config) {			void show_conf(struct parsedfile *config) {
	struct netent *net;						struct netent *net;
	struct serverent *server;					struct serverent *server;

	/* Show the local networks */					/* Show the local networks */
	printf("=== Local networks (no socks server needed) =		printf("=== Local networks (no socks server needed) =
	net = (config->localnets);					net = (config->localnets);
	while (net != NULL) {						while (net != NULL) {
		printf("Network: %15s ",					printf("Network: %15s ",
		       inet_ntoa(net->localip));				       inet_ntoa(net->localip));
		printf("NetMask: %15s\n", 					printf("NetMask: %15s\n", 
		       inet_ntoa(net->localnet));				       inet_ntoa(net->localnet));
		net = net->next;						net = net->next;
	}								}
	printf("\n");							printf("\n");

	/* If we have a default server configuration show it 		/* If we have a default server configuration show it 
	printf("=== Default Server Configuration ===\n");		printf("=== Default Server Configuration ===\n");
	if ((config->defaultserver).address != NULL) {			if ((config->defaultserver).address != NULL) {
		show_server(config, &(config->defaultserver),			show_server(config, &(config->defaultserver),
	} else {							} else {
		printf("No default server specified, this is 			printf("No default server specified, this is 
		       "good idea\n");						       "good idea\n");
	}								}
	printf("\n");							printf("\n");

	/* Now show paths */						/* Now show paths */
	if ((config->paths) != NULL) {					if ((config->paths) != NULL) {
		server = (config->paths);					server = (config->paths);
		while (server != NULL) {					while (server != NULL) {
			printf("=== Path (line no %d in confi				printf("=== Path (line no %d in confi
			       " ===\n", server->lineno);				       " ===\n", server->lineno);
			show_server(config, server, 0);					show_server(config, server, 0);
			printf("\n");							printf("\n");
			server = server->next;						server = server->next;
		}								}	
	} 								} 

#ifdef USE_TOR_DNS						#ifdef USE_TOR_DNS
    /* Show tordns configuration options */			    /* Show tordns configuration options */
    printf("=== TorDNS Configuration Options ===\n");		    printf("=== TorDNS Configuration Options ===\n");
    printf("Tor DNS enabled:        %s\n", 			    printf("Tor DNS enabled:        %s\n", 
           config->tordns_enabled ? "yes" : "no");		           config->tordns_enabled ? "yes" : "no");
    printf("Tor DNS deadpool range: %s/", 			    printf("Tor DNS deadpool range: %s/", 
           inet_ntoa(config->tordns_deadpool_range->localip))	           inet_ntoa(config->tordns_deadpool_range->localip))
    printf("%s\n", 						    printf("%s\n", 
        inet_ntoa(config->tordns_deadpool_range->localnet));	        inet_ntoa(config->tordns_deadpool_range->localnet));
    printf("Tor DNS cache size:     %d\n", config->tordns_cac	    printf("Tor DNS cache size:     %d\n", config->tordns_cac
    printf("\n");						    printf("\n");
#endif								#endif

    return;							    return;
}								}

void show_server(struct parsedfile *config, struct serverent 	void show_server(struct parsedfile *config, struct serverent 
	struct in_addr res;						struct in_addr res;
	struct netent *net;						struct netent *net;

	/* Show address */						/* Show address */
	if (server->address != NULL) 					if (server->address != NULL) 
		printf("Server:       %s (%s)\n", server->add			printf("Server:       %s (%s)\n", server->add
	       		((res.s_addr = resolve_ip(server->add		       		((res.s_addr = resolve_ip(server->add
						  HOSTNAMES)) |							  HOSTNAMES))
			 ? "Invalid!" : inet_ntoa(res)));				 ? "Invalid!" : inet_ntoa(res)));
	else								else
		printf("Server:       ERROR! None specified\n			printf("Server:       ERROR! None specified\n

	/* Check the server is on a local net */			/* Check the server is on a local net */
	if ((server->address != NULL) && (res.s_addr != -1) & |		if ((server->address != NULL) && (res.s_addr != 0) &&
	    (is_local(config, &res))) 					    (is_local(config, &res))) 
		fprintf(stderr, "Error: Server is not on a ne			fprintf(stderr, "Error: Server is not on a ne
				"specified as local\n");					"specified as local\n");

	/* Show port */							/* Show port */
	printf("Port:         %d\n", server->port);			printf("Port:         %d\n", server->port);

	/* Show SOCKS type */						/* Show SOCKS type */
	printf("SOCKS type:   %d\n", server->type);			printf("SOCKS type:   %d\n", server->type);

	/* Show default username and password info */			/* Show default username and password info */
	if (server->type == 5) {					if (server->type == 5) {
		/* Show the default user info */				/* Show the default user info */
		printf("Default user: %s\n", 					printf("Default user: %s\n", 
		       (server->defuser == NULL) ? 				       (server->defuser == NULL) ? 
		       "Not Specified" : server->defuser);			       "Not Specified" : server->defuser);
		printf("Default pass: %s\n", 					printf("Default pass: %s\n", 
		       (server->defpass == NULL) ? 				       (server->defpass == NULL) ? 
		       "Not Specified" : "******** (Hidden)")			       "Not Specified" : "******** (Hidden)")
		if ((server->defuser == NULL) && 				if ((server->defuser == NULL) && 
		    (server->defpass != NULL)) 					    (server->defpass != NULL)) 
			fprintf(stderr, "Error: Default user 				fprintf(stderr, "Error: Default user 
				   "if default pass is specif					   "if default pass is specif
	} else {							} else {
		if (server->defuser) printf("Default user: %s			if (server->defuser) printf("Default user: %s
					    server->defuser);						    server->defuser);
		if (server->defpass) printf("Default pass: %s			if (server->defpass) printf("Default pass: %s
					    server->defpass);						    server->defpass);
		if ((server->defuser != NULL) || (server->def			if ((server->defuser != NULL) || (server->def
			fprintf(stderr, "Error: Default user 				fprintf(stderr, "Error: Default user 
				   "may only be specified for					   "may only be specified for
				   "servers\n");						   "servers\n");
	}								}

	/* If this is the default servers and it has reachnet		/* If this is the default servers and it has reachnet
	if (def) {							if (def) {
		if (server->reachnets != NULL) { 				if (server->reachnets != NULL) { 
			fprintf(stderr, "Error: The default s				fprintf(stderr, "Error: The default s
			       "specified networks it can rea				       "specified networks it can rea
			       "these statements are ignored 				       "these statements are ignored 
			       "default server will be tried 				       "default server will be tried 
			       "which is not specified in a r				       "which is not specified in a r
			       "for other servers\n");					       "for other servers\n");
		}								}
	} else if (server->reachnets == NULL) {				} else if (server->reachnets == NULL) {
		fprintf(stderr, "Error: No reach statements s			fprintf(stderr, "Error: No reach statements s
		       "server, this server will never be use			       "server, this server will never be use
	} else {							} else {
		printf("This server can be used to reach:\n")			printf("This server can be used to reach:\n")
		net = server->reachnets;					net = server->reachnets;
		while (net != NULL) {						while (net != NULL) {
			printf("Network: %15s ",					printf("Network: %15s ",
			       inet_ntoa(net->localip));				       inet_ntoa(net->localip));
			printf("NetMask: %15s ", 					printf("NetMask: %15s ", 
			       inet_ntoa(net->localnet));				       inet_ntoa(net->localnet));
         if (net->startport)					         if (net->startport)
            printf("Ports: %5lu - %5lu",			            printf("Ports: %5lu - %5lu",
                   net->startport, net->endport);		                   net->startport, net->endport);
         printf("\n");						         printf("\n");
			net = net->next;						net = net->next;
		}								}
	}								}
}								}
Only in /home/robert/Development/tork/src/tsocks/: validateconf.c~
